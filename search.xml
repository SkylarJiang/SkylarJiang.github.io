<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Cannot read property bindings of null 解决方法</title>
    <url>/2020/07/03/Cannot-read-property-bindings-of-null-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>babel 的编译问题</p>
<a id="more"></a>

<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>把老的 babel-preset-env 换掉</p>
<h3 id="安装-babel-preset-env"><a href="#安装-babel-preset-env" class="headerlink" title="安装@babel/preset-env"></a>安装@babel/preset-env</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">npm install @babel/preset-env</span><br></pre></td></tr></table></figure>

<h3 id="更新配置项"><a href="#更新配置项" class="headerlink" title="更新配置项"></a>更新配置项</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把</span></span><br><span class="line">preset: [<span class="string">"env"</span>]</span><br><span class="line"><span class="comment"># 换成</span></span><br><span class="line">presets: [<span class="string">"@babel/preset-env"</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>一些坑</tag>
      </tags>
  </entry>
  <entry>
    <title>Git &amp; GitHub小结</title>
    <url>/2020/06/29/Git-GitHub/</url>
    <content><![CDATA[<p>Git 是目前世界上最先进的分布式版本控制系统；GitHub 为开源项目免费提供Git存储。</p>
<a id="more"></a>

<p><strong>目录</strong>：</p>
<!-- TOC -->

<ul>
<li><a href="#hellogit">helloGit</a></li>
<li><a href="#创建版本库">创建版本库</a></li>
<li><a href="#本地库操作小结">本地库操作小结</a></li>
<li><a href="#远程库">远程库</a></li>
<li><a href="#分支管理">分支管理</a><ul>
<li><a href="#解决冲突">解决冲突</a></li>
<li><a href="#分支管理策略">分支管理策略</a></li>
<li><a href="#bug分支">bug分支</a></li>
<li><a href="#feature-分支">Feature 分支</a></li>
<li><a href="#多人协作">多人协作</a></li>
</ul>
</li>
<li><a href="#标签管理">标签管理</a></li>
<li><a href="#使用-github">使用 GitHub</a></li>
<li><a href="#gitee">Gitee</a></li>
<li><a href="#自定义">自定义</a></li>
<li><a href="#sourcetree">SourceTree</a></li>
</ul>
<!-- /TOC -->

<h2 id="helloGit"><a href="#helloGit" class="headerlink" title="helloGit"></a>helloGit</h2><p>Git 是目前世界上最先进的分布式版本控制系统<br>GitHub 为开源项目免费提供Git存储</p>
<p>分布式和集中式版本控制系统：</p>
<p>集中式：集中存放在中央服务器，必须联网才能工作，效率低。<br>分布式：每个人的电脑都是一个完整的版本库，协作时只需要把各自的修改推送给对方，无需联网也可以工作；有一台充当“中央服务器”的电脑，用来方便交换大家的修改</p>
<h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><p>版本库，repository，版本库下所有文件都可以被 Git 管理起来，每个文件的修改、删除 Git 都能跟踪</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个空文件</span></span><br><span class="line"><span class="comment"># 1. 显示当前目录</span></span><br><span class="line">    $ <span class="built_in">pwd</span></span><br><span class="line"><span class="comment"># 2. 初始化：把目录变成 Git 可以管理的仓库</span></span><br><span class="line">    $ git init</span><br><span class="line"><span class="comment"># 生成一个 .git 目录，是 Git 来追踪管理版本库的</span></span><br><span class="line"><span class="comment"># 这是一个隐藏目录，可以让他显示</span></span><br><span class="line">    $ ls -ah</span><br></pre></td></tr></table></figure>

<ul>
<li>把文件添加到版本库</li>
</ul>
<p>版本库只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码（word 文件不可以）等等；而图片、视频等二进制文件就无法跟踪变化</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编写一个文件，readme.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 把文件添加到仓库</span></span><br><span class="line">$ git add &lt;file&gt;</span><br><span class="line">$ git add readme.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 把文件提交到仓库（-m 后面输入本次提交的说明）</span></span><br><span class="line">$ git commit -m &lt;message&gt;</span><br><span class="line">$ git commit -m <span class="string">"wrote a readme file"</span></span><br><span class="line"><span class="comment"># commit 一次可以提交多个 add 进来的内容</span></span><br></pre></td></tr></table></figure>

<ul>
<li>修改与版本</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看仓库状态，修改信息、提交状态等</span></span><br><span class="line">    $ git status</span><br><span class="line">    <span class="comment"># working tree clean</span></span><br><span class="line">    <span class="comment"># Changes to be committed:...</span></span><br><span class="line"><span class="comment"># 查看具体被修改的内容 —— Unix 通用的 diff 格式显示</span></span><br><span class="line">    $ git diff &lt;file&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 版本回退</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 查看历史记录 —— 显示所有的版本记录</span></span><br><span class="line">    $ git <span class="built_in">log</span></span><br><span class="line">    $ git <span class="built_in">log</span> --pretty=oneline</span><br><span class="line">    <span class="comment"># commit id : 是 SHA 计算出的十六进制数字，避免冲突</span></span><br><span class="line">    <span class="comment"># Author &amp; Date &amp; message</span></span><br><span class="line"><span class="comment"># 2. 回退</span></span><br><span class="line"><span class="comment">#  版本表示：</span></span><br><span class="line">    HEAD --&gt; 当前版本</span><br><span class="line">    HEAD^ --&gt; 上一版本</span><br><span class="line">    HEAD^^ --&gt; 上上版本</span><br><span class="line">    HEAD~100 --&gt; 往上 100 个</span><br><span class="line"><span class="comment">#  命令：</span></span><br><span class="line">    $ git reset --hard HEAD^ / commit id</span><br><span class="line"><span class="comment"># 【内部有个指向当前版本的 HEAD 指针，版本回退只是更改指针指向】</span></span><br><span class="line"></span><br><span class="line">----此时通过 status 已经无法读取之后版本了----</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回更新的版本</span></span><br><span class="line"><span class="comment"># 通过 commit id 回退，则需要查看命令的 id</span></span><br><span class="line">    $ git reflog</span><br></pre></td></tr></table></figure>

<h2 id="本地库操作小结"><a href="#本地库操作小结" class="headerlink" title="本地库操作小结"></a>本地库操作小结</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">|—— 工作区 ==&gt; add</span><br><span class="line">|—— 版本库</span><br><span class="line">    +—— stage 暂存区  =&gt; commit</span><br><span class="line">    +—— master 分支：创建 Git 版本库时，自动为我们创建的唯一分支</span><br><span class="line">        提交到这里就是已经在仓库了</span><br><span class="line">     —— HEAD：指向 master 的指针</span><br></pre></td></tr></table></figure>

<ul>
<li>回退</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> <span class="comment"># 工作区回退</span></span><br><span class="line">git reset HEAD \&lt;file&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂存库回退</span></span><br><span class="line">git checkout -- \&lt;file&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 版本库回退</span></span><br><span class="line"><span class="comment"># 1. 查看 git 版本操作记录</span></span><br><span class="line">git <span class="built_in">log</span> --pretty=oneline</span><br><span class="line">git reflog</span><br><span class="line"><span class="comment"># 2. 改变版本</span></span><br><span class="line">git reset --hard HEAD^</span><br><span class="line">git reset --hard \&lt;版本号id&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">+—— rm \&lt;file&gt;</span><br><span class="line">    +——<span class="comment"># 确实要删</span></span><br><span class="line">    |   +—— git rm \&lt;file&gt;</span><br><span class="line">    |   +—— git commit -m &lt;message&gt;</span><br><span class="line">    +—— 删错了 git checkout -- test.txt</span><br></pre></td></tr></table></figure>

<h2 id="远程库"><a href="#远程库" class="headerlink" title="远程库"></a>远程库</h2><p>咋回事</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 远程仓库和本地仓库相关联，关联后远程库默认叫 origin</span></span><br><span class="line">git remote add origin git@github.com...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把本地内容（当前分支 master）推送到远程库</span></span><br><span class="line">git push</span><br><span class="line"><span class="comment"># 第一次推送时还需要关联本地的 master 和远程的 master</span></span><br><span class="line"><span class="comment"># 则应该用</span></span><br><span class="line">git push -u oringin master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送最新修改到远端</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从远程库克隆到本地库</span></span><br><span class="line"><span class="comment"># Git支持多种协议，ssh协议速度最快</span></span><br><span class="line">git <span class="built_in">clone</span>@..</span><br><span class="line"><span class="comment"># 还可以https</span></span><br><span class="line">git <span class="built_in">clone</span> https:...</span><br></pre></td></tr></table></figure>

<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>分支：<br>工作时避免互相干扰，开发完毕后再一次性合并到原来的分支上</p>
<p>HEAD 指针、分支、提交点：<br>HEAD 指向当前分支，分支有个指针指向当前的提交点</p>
<p>新建分支：<br>如果建了新的分支 dev，就是新建对应的 dev 指针（指向最新的提交点），改变 HEAD 的指向，工作区没有变化<br>我们不断更新版本，dev 指针在版本链上的指针改变</p>
<p>合并分支：有普通合并和快合并</p>
<p>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. <span class="comment"># 新建分支</span></span><br><span class="line">    git branch dev</span><br><span class="line">    <span class="comment"># 切换分支</span></span><br><span class="line">    git checkout dev</span><br><span class="line">    git seitch dev</span><br><span class="line">    <span class="comment"># 命令合并：新建并切换分支</span></span><br><span class="line">    git checkout -b dev</span><br><span class="line">    git switch -c dev</span><br><span class="line">    <span class="comment"># 查看分支：列出所有分支，当前分支带 *</span></span><br><span class="line">    git branch</span><br><span class="line"></span><br><span class="line">2. <span class="comment"># 然后正常修改正常提交</span></span><br><span class="line">3. <span class="comment"># 合并分支</span></span><br><span class="line">    git switch master <span class="comment"># 切回来</span></span><br><span class="line">    git merge dev <span class="comment"># 合并指定分支到当前分支（指向dev工作点）</span></span><br><span class="line">    <span class="comment"># 没有冲突，快速合并</span></span><br><span class="line">    git branch -d dev <span class="comment"># 删除分支</span></span><br></pre></td></tr></table></figure>

<h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><ol>
<li>快速合并和禁用快合并</li>
<li>手动解决冲突再进行合并<br> 这时有冲突的文件会有标记显示不同分支有冲突的内容<br> 手动进行修改合并后保存，重新 add &amp; commit</li>
</ol>
<p>删除分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">查看合并情况：</span><br><span class="line">git <span class="built_in">log</span> --graph 查看分支合并图</span><br><span class="line">git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure>

<h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h3><p>禁用快速合并: –no-ff 方式的 git merge<br>可以在 merge 的时候生成一个带描述的 commit ，而不是默默就合并了，可以看出合并记录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge --no-ff -m <span class="string">"merge with no-ff"</span> dev</span><br></pre></td></tr></table></figure>

<p>快速模式合并就是没有冲突的时候只改变原来 master 分支的指针，指到新分支最新的版本去<br>而强制关闭 ff 模式，则会新建一个不同于 dev 最新版的 commit ，这样可以看出 dev 的版本，这样删除分支后就不会丢失分支信息，可以看出来曾经做过合并</p>
<ul>
<li>分支策略</li>
</ul>
<p>工作中一般不直接在 master 分支上操作，仅用来发布新版本<br>工作团队就在 dev 分支上工作</p>
<h3 id="bug分支"><a href="#bug分支" class="headerlink" title="bug分支"></a>bug分支</h3><ul>
<li>通过新建分支来修复 bug 再进行合并</li>
<li>此时如果还有别的分支上的工作还在进行，可以同过<code>stash</code>功能来把当前工作现场先保存，再新建别的分支修复 bug</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">+—— git stash <span class="comment"># 储存起来</span></span><br><span class="line">+—— <span class="comment"># 出去新建分支 debug</span></span><br><span class="line">+—— git stash list <span class="comment"># 列出现场</span></span><br><span class="line">+—— <span class="comment"># 恢复现场</span></span><br><span class="line">    +—— git stash apply &lt;stash@id&gt; <span class="comment"># 查看，该现场还在现场列表中</span></span><br><span class="line">    |    git stash drop <span class="comment"># 删除 stash 内容</span></span><br><span class="line">    +—— git stash pop <span class="comment"># 弹出现场，删除栈顶现场</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># master 分支上的 bug 也需要在其他分支修复</span></span><br><span class="line"><span class="comment"># 这个时候可以直接把指定的改动赋值到指定分支</span></span><br><span class="line">    +—— git cherry-pick \&lt;commit id&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Feature-分支"><a href="#Feature-分支" class="headerlink" title="Feature 分支"></a>Feature 分支</h3><ul>
<li>添加新功能</li>
<li>添加新功能的时候先再新建的 feature 分支上开发，完成后再合并</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 要丢弃一个还没被合并过的分支需要强行删除</span></span><br><span class="line">git branch -D &lt;name&gt;</span><br></pre></td></tr></table></figure>

<h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看远程库信息</span></span><br><span class="line">git remote</span><br><span class="line">git remove -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送分支</span></span><br><span class="line">git push origin branchName</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主分支和开发分支都需要远程同步</span></span><br><span class="line"><span class="comment"># bug 分支和 feature看情况啦</span></span><br></pre></td></tr></table></figure>

<p>多人协作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 抓取分支</span></span><br><span class="line"><span class="comment"># 从远程库克隆时默认情况下只能看到本地的 master</span></span><br><span class="line"><span class="comment"># 需要创建远程 origin 的 dev 到本地</span></span><br><span class="line">git checkout -b dev origin/dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决冲突</span></span><br><span class="line"><span class="comment"># git push 时有冲突</span></span><br><span class="line"><span class="comment"># 两人同时修改了同个文件相同位置的内容</span></span><br><span class="line"><span class="comment"># 先把最新提交从 origin/dev 抓下来</span></span><br><span class="line">git branch --<span class="built_in">set</span>-upstream-to=origin/\&lt;branch&gt; dev</span><br><span class="line">git pull</span><br><span class="line"><span class="comment"># 在本地合并，解决冲突再 push</span></span><br></pre></td></tr></table></figure>

<p>Rebase</p>
<p>rebase操作可以把本地未push的分叉提交历史整理成直线</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把多人协作解决冲突的提交历史的提交整理成一条直线</span></span><br><span class="line">git rebase</span><br></pre></td></tr></table></figure>

<p>操作后 commit 会被挪动位置，从而修改的内容也会发生变化，但是提交的内容是一致的</p>
<h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><p>在版本库中给版本打一个标签（tag），方便取出<br>是版本库的快照，实际上就是指向某个 commit 的指针</p>
<p>标签的创建：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先切换到需要打标签的分支上</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建标签</span></span><br><span class="line"><span class="comment"># 给最新 commit 打标签</span></span><br><span class="line">git tag &lt;tagName&gt;</span><br><span class="line"><span class="comment"># 给历史 commit</span></span><br><span class="line">git tag &lt;tagName&gt; \&lt;commit id&gt;</span><br><span class="line"><span class="comment"># 创建带说明的 tag</span></span><br><span class="line"><span class="comment"># 用 -a 指定标签名，-m 指定 messege</span></span><br><span class="line">git tag -a &lt;tagName&gt; -m <span class="string">""</span> &lt;commit id&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看有哪些标签</span></span><br><span class="line">git tab</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某标签指向的 commit 的具体说明文字</span></span><br><span class="line">git show &lt;tagName&gt;</span><br></pre></td></tr></table></figure>

<p>标签的操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 推送到远端</span></span><br><span class="line">git push origin &lt;tagName&gt;</span><br><span class="line">git push origin --tags</span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地删除</span></span><br><span class="line">git tag -d &lt;tagName&gt;</span><br><span class="line"><span class="comment"># 远端删除</span></span><br><span class="line"><span class="comment"># 先在本地删除，再</span></span><br><span class="line">git push origin :refs/tags/&lt;name\&gt;</span><br></pre></td></tr></table></figure>

<h2 id="使用-GitHub"><a href="#使用-GitHub" class="headerlink" title="使用 GitHub"></a>使用 GitHub</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Fork <span class="comment"># Fork 开源项目到自己的仓库</span></span><br><span class="line">git <span class="built_in">clone</span> <span class="comment"># 克隆到本地</span></span><br><span class="line"><span class="comment"># 然后就可以自己进行修复、增加功能等操作了</span></span><br><span class="line">pull request <span class="comment"># 给官方贡献代码</span></span><br></pre></td></tr></table></figure>

<h2 id="Gitee"><a href="#Gitee" class="headerlink" title="Gitee"></a>Gitee</h2><p>国内的 git 托管服务<br>提供免费的 Git 仓库<br>本地库可以既关联 GitHub 又关联 Gitee</p>
<h2 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h2><ol>
<li><p>部署别名</p>
</li>
<li><p>忽略特殊文件<br> <code>gitignore</code><br> 在<code>.gitignore</code>中写入文件名或者正则表达式</p>
</li>
<li><p>配置别名：例如更改一些命令</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在全局把 status 命令改成 st</span></span><br><span class="line">git config --global alias.st status</span><br></pre></td></tr></table></figure>

<p> 配置文件在<code>.git/config</code><br> 别名在 <code>[alias]</code> 中</p>
</li>
<li><p>搭建 Git 服务器<br> 有缘再学</p>
</li>
</ol>
<h2 id="SourceTree"><a href="#SourceTree" class="headerlink" title="SourceTree"></a>SourceTree</h2><p>GUI 工具<br>图形界面工具<br>明天看看</p>
<hr>
<p>参考：</p>
<p><a href="https:#www.liaoxuefeng.com/wiki/896043488029600">廖雪峰老师的 Git 教程</a></p>
]]></content>
      <categories>
        <category>工具</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title>web security</title>
    <url>/2020/07/22/7.22_web-security/</url>
    <content><![CDATA[<h2 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h2><h3 id="Web-页面安全"><a href="#Web-页面安全" class="headerlink" title="Web 页面安全"></a>Web 页面安全</h3><p>严格的同源策略会更加安全，但是也束缚了 Web。于是在默认页面中引入任意第三方资源，又引入 <code>CSP</code> 策略加以限制；默认 <code>XMLHttpRequest</code> 和 <code>Fetch</code> 不能跨站请求资源又通过 <code>CORS</code> 策略来支持其跨域。</p>
<p>页面安全问题主要也是浏览器为同源策略开的这两个后门引起的啦</p>
<h4 id="1-跨站脚本攻击（XSS）"><a href="#1-跨站脚本攻击（XSS）" class="headerlink" title="1. 跨站脚本攻击（XSS）"></a>1. 跨站脚本攻击（XSS）</h4><ul>
<li><p>是什么</p>
<p>Cross Site Scripting —— 是指黑客网 HTML 文件或 DOM 中注入而已脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击。</p>
<ul>
<li>可以窃取 Cookie 信息</li>
<li>监听用户行为</li>
<li>修改 DOM</li>
<li>在页面生成浮窗广告</li>
</ul>
</li>
<li><p>恶意脚本是怎么注入的</p>
<ul>
<li><p>存储型 XSS 攻击</p>
<ul>
<li>利用站点漏洞将一段恶意 JavaScript 代码提交到网站的数据库</li>
<li>用户想网站请求带有而已 JavaScript 脚本的页面</li>
<li>当浏览器浏览该页面的时候，而已脚本就可以将用户的 cookie 信息等通过 <code>XMLHTTPRequest</code>或<code>Fetch</code>上传到恶意服务器</li>
</ul>
</li>
<li><p>反射型 XSS 攻击</p>
<p>恶意用户把 JavaScript 作为网络请求的一部分，随后网站把恶意 JavaScript 脚本返回给用户时，被加入的恶意脚本就可以执行</p>
</li>
<li><p>基于 DOM 的 XSS 攻击</p>
<p>这种攻击不牵涉到页面的 Web 服务器。黑客通过各种手段将而已脚本注入用户的页面中，如通过网络劫持在页面传输过程中修改 HTML 内容等。是在 web 资源传输过程中或者在用户使用页面的过程中修改 Web 页面数据。</p>
</li>
</ul>
</li>
<li><p>如何阻止</p>
<ul>
<li><p>服务器对输入脚本进行过滤或转码，如<code>&lt;script&gt;</code></p>
</li>
<li><p>充分利用 <code>CSP</code></p>
<ul>
<li>限制加载其他域下的资源文件</li>
<li>禁止向第三方提交数据</li>
<li>禁止执行内联脚本或未授权的脚本</li>
<li>提供上报机制</li>
</ul>
</li>
<li><p>使用 <code>HttpOnly</code> 属性</p>
<p>许多 <code>xss</code> 都是来窃取 Cookie 的</p>
</li>
</ul>
</li>
</ul>
<h4 id="2-CSRF-攻击"><a href="#2-CSRF-攻击" class="headerlink" title="2. CSRF 攻击"></a>2. CSRF 攻击</h4><p>（陌生链接不要随便点）</p>
<ul>
<li><p>是什么</p>
<p>Cross-site request forgery，跨站请求伪造，通常是引诱用户打开网站，在这个网站中，利用用户的登录状态发起跨站请求</p>
</li>
<li><p>怎么攻击</p>
<ul>
<li><p>自动发起 Get 请求</p>
<p>如把转账请求接口隐藏在 <code>img</code>标签里</p>
</li>
<li><p>自动发起 POST 请求</p>
<p>构建隐藏表单，点开后表单自动执行</p>
</li>
<li><p>引诱用户点击链接</p>
<p>引诱用户点击图片下载链接</p>
</li>
</ul>
</li>
<li><p>如何防止</p>
<ul>
<li><p>Cookie的 <code>SameSite</code> 属性</p>
<p>黑客利用用户的登录状态来发起 CSRF 攻击，而 Cookie 是浏览器和服务器之间维护登录状态的一个关键数据。最好保证，如果是第三方发来的请求就禁止发送关键Cookie、session 数据，同行一个网站就可以。可以通过在 HTTP 响应头中通过 <code>set-cookie</code>字段设置时，带上<code>SameSite</code>选项来实现。</p>
<ul>
<li><p>strict —— 完全禁止第三方</p>
</li>
<li><p>Lax —— 在第三方站点中使用 Post 方法时、通过 <code>img</code> 、<code>iframe</code>标签加载的 URL 不会懈怠 Cookie</p>
</li>
<li><p>None —— 任何情况都会发送</p>
</li>
</ul>
</li>
<li><p>验证请求的来源网站</p>
<p>服务器要怎么判断请求是否来自第三方站点呢？HTTP 请求中的 <code>Referer</code>字段，记录了该 HTTP 请求的来源地址；以及<code>Origin</code>属性包含域名信息，没有具体路径。但是有时候为了安全不适合将源 URL 暴露给服务器，所以服务器的策略是优先判断 <code>Origin</code>属性，如果请求头中没有包含，那就根据实际情况判断是否使用 <code>Referer</code> 值</p>
<p>针对重要的才做，需要再次验证，如短信验证码，确保你是你。</p>
</li>
<li><p>CSRF Token</p>
<p>敏感接口数据采取加密传输、新增时效性或随机参数，增加信息不确定性。如</p>
<p>浏览器发起请求时，服务器生成一个 CSRF Token（一个字符串），并把它植入返回的页面中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action=<span class="string">"https://...."</span> method=<span class="string">"POST"</span>&gt;</span><br><span class="line">      &lt;input type=<span class="string">"hidden"</span> name=<span class="string">"csrf-token"</span> value=<span class="string">"nc98P987bcpncYhoadjoiydc9ajDlcn"</span>&gt;</span><br><span class="line">      ....</span><br><span class="line">    &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在浏览器端如果要发起转账的请求，就需要带上页面上的 CSRF Token，服务器会进行验证</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="安全沙箱"><a href="#安全沙箱" class="headerlink" title="安全沙箱"></a>安全沙箱</h3><p>隔离渲染进程和操作系统</p>
<ul>
<li><p>是什么</p>
<p>渲染进程中需要执行 DOM 解析，CSS 解析，网络图片解码等操作，如果渲染进程中存在系统级别的漏洞诶恶意站点获取到，进而获取操作系统的控制权限，就十分危险。而安全沙箱是隔离渲染进程和操作系统的一道墙。</p>
<p>安全沙箱让渲染进程在执行过程中无法访问或修改操作系统的数据，当需要访问系统资源时，需要通过浏览器内核来实现，然后将访问的结果通过 <code>IPC</code> 转发给渲染进程。</p>
<p>安全沙箱最小的保护单位是进程，所以单进程浏览器是无法被安全沙箱保护的</p>
</li>
<li><p>安全沙箱怎么影响各个模块功能</p>
<blockquote>
<p>先复习一下渲染进程和浏览器内核各自职责：</p>
<p>渲染进程：HTML 解析、CSS 解码、图片解码、JavaScript执行、布局、绘制、XML 解析</p>
<p>浏览器内核： Cookie 存储、Cache 存储、网络请求、文件读取、下载管理、SSL/TSL、浏览器窗口管理</p>
</blockquote>
<ul>
<li><p>持久存储：为了解决渲染进程对 Cookie、文件的访问需求，现代浏览器把读写文件的操作全都放在了浏览器内核中实现，然后通过 <code>IPC</code>转发给渲染进程</p>
</li>
<li><p>网络访问：有了沙箱保护，在渲染进程内部不能知直接访问网络，还是需要通过浏览器内核。而浏览器内核会对请求的 URL 进行检查</p>
</li>
<li><p>用户交互：</p>
<p><u>窗口句柄</u>：要实现 UI 程序时，操作系统会提供一个界面，允许应用程序与用户交互</p>
<p>渲染进程不能直接操作窗口句柄：需要先渲染出位图，送到浏览器内核；操作系统没有将用户输入施加直接传递给渲染进程，而是将事件传递给浏览器内核，再根据界面状态进行处理。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p> 为什么一定要通过浏览器内核请进化成资源，再发送给渲染进程，而不是从进程内部请求网络资源？</p>
<p>为什么渲染进程只负责生成页面图片，生成图片还要经过 IPC 通知浏览器内核模块，然后让浏览器内核去展示图片？</p>
</blockquote>
<h4 id="站点隔离（Site-Isolation）"><a href="#站点隔离（Site-Isolation）" class="headerlink" title="站点隔离（Site Isolation）"></a>站点隔离（Site Isolation）</h4><p>Chrome 将统一站点（包含了相同根域名和相同协议的地址）中互联的页面放到同一个渲染进程中执行。最初是按照标签页来划分渲染进程的，如果一个标签里有多个不同源的 <code>iframe</code> ，那么这些 <code>iframe</code> 也会被分配到同一个渲染进程张红，这样就很容易让黑客通过 <code>iframe</code> 来攻击当前渲染进程中。</p>
<p>而站点隔离会将不同源的  <code>iframe</code> 分配到不同的渲染进程中，这样黑客进行攻击时也不会影响到其他渲染进程。</p>
<hr>
<h3 id="网络安全：网络安全协议-HTTPS"><a href="#网络安全：网络安全协议-HTTPS" class="headerlink" title="网络安全：网络安全协议 HTTPS"></a>网络安全：网络安全协议 HTTPS</h3><ul>
<li><p>中间人攻击与安全层：</p>
<p>HTTP 是以明文传输数据的，在将 HTTP 数据提交给 TCP 层后，传输过程中的每一个环节，数据都有可能在到达服务器之前被窃取或者篡改，这意味着可能还有个中间人在掌控着通信过程。于是在 TCP 和 HTTP 之间插入一个<strong>安全层</strong> SSL ，他的职责是，对发起 HTTP 请求的数据进行加密操作和对接收到的 HTTP 内容进行解密操作。</p>
<blockquote>
<p>HTTPS 使用 SSL（Secure Socket Layer） 和 TLS（Transport Layer Security）这两个协议。TSL 是以 SSL 为原型开发的协议，有时会统一称该协议为 SSL。HTTPS，其实就是身披 SSL 协议这层外壳的 HTTP。</p>
</blockquote>
</li>
<li><p>流程：</p>
<ul>
<li><p>发送方，SSL 接收应用层的数据（HTTP 或 IMAP 报文），对数据进行加密，然后把加密后的纾解送往 TCP 套接字。</p>
</li>
<li><p>在接收方，SSL 从 TCP 套接字读取书，解密后把数据交给应用层。</p>
</li>
</ul>
</li>
<li><p>https使用的是 443 端口</p>
</li>
<li><p>一开始需要协商安全套接字，所以一开始不太快</p>
</li>
</ul>
<h3 id="HTTPS-协议"><a href="#HTTPS-协议" class="headerlink" title="HTTPS 协议"></a>HTTPS 协议</h3><h4 id="1-加密技术"><a href="#1-加密技术" class="headerlink" title="1.  加密技术"></a>1.  加密技术</h4><p>报文经过加密算法生成密文，伪装数据，使入侵者不能从截取的数据中获取任何信息。</p>
<p>A 为加密算法提供一个秘钥，加密算法以秘钥和明文报文为输入，生成的密文作为输出。</p>
<p>B 为解密算法提供一个秘钥，解密算法以秘钥和密文为输入，初始报文为输出，</p>
<p>对称加密</p>
<p><strong>对称秘钥系统</strong>——对称加密中，A 和 B 秘钥是相同的且秘密的。</p>
<p>对称秘钥加密时，密钥需要发给对方。在互联网上转发密钥时，如果通信被监听那么密钥就可会落入攻击者之手，同时也就失去了加密的意义。另外还得设法安全地保管接收到的密钥。</p>
<p><strong>公开秘钥系统</strong>——非对称加密</p>
<p>公开密钥加密使用一对非对称的密钥。</p>
<ul>
<li>私有密钥（private key）：不能让其他任何人知道</li>
<li>公开密钥（public key）：公开密钥则可以随意发布，任何人都可以获得。</li>
<li>服务端用私钥加密的内容，可以通过它的公钥进行解密</li>
</ul>
<p>但是存在加密效率太低、无法保证服务器发送给浏览器的数据安全（私钥加密公钥解密，但是公钥是可以被获取的）</p>
<p><strong>HTTPS 采用混合加密机制</strong> —— 非对称加密交换秘钥、对称加密数据</p>
<p>DNS 劫持、如何保证服务器是可信的？</p>
<p><strong>需要CA 权威机构保证服务的可信性</strong>⬇⬇⬇⬇⬇</p>
<h4 id="2-数字证书："><a href="#2-数字证书：" class="headerlink" title="2.  数字证书："></a>2.  数字证书：</h4><ul>
<li><p>数字签名：</p>
<ul>
<li><p>根据内容用密码散列函数 <code>hash</code> 计算得出一个摘要，然后用私钥加密，把公钥、加密后的摘要（二进制128位）、文件一起传输</p>
</li>
<li><p>得到后用公钥解密，并比对生成的签名是否一致</p>
</li>
<li><p>能够防止发送防抵赖，也能能够确保内容不被篡改</p>
</li>
</ul>
</li>
<li><p>证书：</p>
<ul>
<li><p>怎么样才能知道私钥是谁的呢，需要证书颁发机构——<code>CA</code>进行认证</p>
</li>
<li><p>流程：</p>
<ul>
<li>申请，CA 给申请人产生证书，里面有公钥和私钥，有 CA 的签名</li>
<li>送出去的公钥上会有 <code>CA</code>的签名，看公钥的来源，先确认一下是不是 CA 发放的，有没有更改过</li>
</ul>
</li>
<li><p>申请证书要通过域名来缴费</p>
</li>
<li><p>如果数字证书丢了，要向证书颁发机构挂失，放到 CRL 中</p>
</li>
</ul>
</li>
</ul>
<h4 id="3-HTTPS-工作流程"><a href="#3-HTTPS-工作流程" class="headerlink" title="3. HTTPS 工作流程"></a>3. HTTPS 工作流程</h4><p>TTP + 加密 + 认证 + 完整性保护 = HTTPS</p>
<img src="http://pictures-by-skylar.oss-cn-shenzhen.aliyuncs.com/img/@Z9FN[P`7Z~}KOKRGHO13OT.png" alt="img" style="zoom:80%;" />

<pre><code>1. 1️⃣客户端通过发送 Client Hello 报文开始 SSL 通信
- 客户端生成的随机数 random1
- 客户端支持的 SSL 版本号
- 加密组件（ Cipher Suite）列表：所使用的的加密算法及密钥长度等</code></pre><ol start="2">
<li><p>服务器发送进行应答</p>
<ol>
<li><p>2️⃣ Server Hello 报文</p>
<ul>
<li>确认通信协议版本；</li>
<li>筛选并确认加密组件；</li>
<li>服务器生成的随机数 random 2</li>
</ul>
</li>
<li><p>3️⃣服务器证书 Certificate</p>
</li>
<li><p>4️⃣确认</p>
</li>
</ol>
</li>
<li><p>客户端回应</p>
<p>验证证书有效性，若证书不是可信机构颁发的，或者证书中域名和实际域名不一样，或者已过期，就会向访问者显示一个警告，由其选择是否还要通信。如果证书没问题，则用 random1 和 random2 生成 <code>pre-master</code>，并从证书中取出服务器的公钥进行加密，然后向服务器发送</p>
<ol>
<li><p>5️⃣上面生成的随机数 <code>pre-master</code>（用公钥加密）</p>
</li>
<li><p>6️⃣编码改变通知：提示服务器此后报文通信将采用  <code>pre-master</code> 密钥加密</p>
</li>
<li><p>⑦ Finish报文：客户端握手结束通知。该报文包含连接至今全部报文的整体叫验证，这次握手协商能否成功，要以服务器是否能够正确解密该报文作为判定标准。</p>
</li>
</ol>
</li>
<li><p>服务器你收到第三个随机数之后，计算本次会话所用的会话加密，然后向客户端发送：</p>
<ul>
<li>8️⃣编码改变通知</li>
<li>9️⃣Finish报文：服务器握手结束，也是前面所有内容的 hash 值，供服务器校验—</li>
</ul>
<p>————————–至此握手已经成功，SSL 连接建立完成————————-</p>
</li>
<li><p>可以进行应用层协议通信了</p>
<ol>
<li>发送 HTTP 请求</li>
<li>HTTP 响应</li>
<li>断开连接</li>
</ol>
</li>
</ol>
<h4 id="4-HTTPS-存在的问题"><a href="#4-HTTPS-存在的问题" class="headerlink" title="4. HTTPS 存在的问题"></a>4. HTTPS 存在的问题</h4><p>HTTPS 也存在一些问题，那就是当使用 SSL 时，它的处理速度会变慢。</p>
<p>SSL证书信用体系不绝对安全</p>
<hr>
<h2 id="Internet-上使用的安全协议"><a href="#Internet-上使用的安全协议" class="headerlink" title="Internet 上使用的安全协议"></a>Internet 上使用的安全协议</h2><h3 id="应用层安全SSL"><a href="#应用层安全SSL" class="headerlink" title="应用层安全SSL"></a>应用层安全SSL</h3><p>在 Internet 上使用的安全协议</p>
<p>imaps tcp-993</p>
<p>pop3 tcp-995</p>
<p>smtps tcp-465</p>
<p>https tcp-443 </p>
<h4 id="SSL除了加密之外还有别的功能"><a href="#SSL除了加密之外还有别的功能" class="headerlink" title="SSL除了加密之外还有别的功能"></a>SSL除了加密之外还有别的功能</h4><ul>
<li>SSL 服务器鉴别：允许用户验证服务器的身份，具有 SSL 功能的浏览器上维持一个表，上面有可信赖的认证中心 CA 和它们的公钥</li>
<li>加密的 SSL 会话</li>
<li>SSL 客户鉴别</li>
</ul>
<h3 id="网络层安全IPSec"><a href="#网络层安全IPSec" class="headerlink" title="网络层安全IPSec"></a>网络层安全IPSec</h3><p>网卡加密</p>
<p>身份验证，协商加密秘钥</p>
<h4 id="安全关联-SA-（security-association）"><a href="#安全关联-SA-（security-association）" class="headerlink" title="安全关联 SA （security association）"></a>安全关联 SA （security association）</h4><p>两个通信实体经协商建立起来的一种协定，决定保护数据分组安全的安全协议（AH 或 ESP 协议）、转码方式、秘钥及秘钥的有效存在时间</p>
<h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><h5 id="鉴别首部-AH"><a href="#鉴别首部-AH" class="headerlink" title="鉴别首部 AH"></a>鉴别首部 AH</h5><p>签名不加密</p>
<p>鉴别源点和检查数据完整性，但不能保密</p>
<p>使用鉴别首部协议 AH 的时候，把 AH 首部插在元数据报数据部分的前面，同时把 IP 首部的协议字段设置为51，再加上 IP 首部</p>
<p>传输过程中中间路由不查看 AH 首部，到达的时候目的主机才处理，然后进行鉴别</p>
<h5 id="封装安全有效载荷-ESP"><a href="#封装安全有效载荷-ESP" class="headerlink" title="封装安全有效载荷 ESP"></a>封装安全有效载荷 ESP</h5><p>签名+加密</p>
<hr>
<p>Reference：</p>
<p><a href="https://everbrez.github.io/network/2019/02/22/HTTPS/" target="_blank" rel="noopener">https://everbrez.github.io/network/2019/02/22/HTTPS/</a></p>
<p><a href="https://time.geekbang.org/column/intro/216" target="_blank" rel="noopener">极客时间-浏览器工作原理及实践-浏览器安全</a></p>
<p>《图解 HTTP》</p>
]]></content>
      <tags>
        <tag>Browser security</tag>
      </tags>
  </entry>
  <entry>
    <title>Cookie</title>
    <url>/2020/07/20/Cookie/</url>
    <content><![CDATA[<h2 id="Cookie-是什么"><a href="#Cookie-是什么" class="headerlink" title="Cookie 是什么"></a>Cookie 是什么</h2><p>是浏览器储存再用户电脑上的一小段文本文件。一个 Web 页面或服务器告知浏览器安</p>
]]></content>
      <tags>
        <tag>NetWork</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP</title>
    <url>/2020/07/20/HTTP/</url>
    <content><![CDATA[<h2 id="0-是什么"><a href="#0-是什么" class="headerlink" title="0 是什么"></a>0 是什么</h2><p>HTTP 定义了浏览器（即万维网客户进程）怎样向万维网服务器请求万维网文档，以及万维网如何把万维网文档传给浏览器。HTTP 基于 TCP/IP 通信协议来传输数据的（HTML 文件、图片文件、查询结果等）</p>
<h2 id="1-HTTP-报文结构"><a href="#1-HTTP-报文结构" class="headerlink" title="1 HTTP 报文结构"></a>1 HTTP 报文结构</h2><h3 id="1-1-客户端请求消息"><a href="#1-1-客户端请求消息" class="headerlink" title="1.1 客户端请求消息"></a>1.1 客户端请求消息</h3><ul>
<li>请求行（request line）</li>
<li>请求头部（header）</li>
<li>空行</li>
<li>请求数据</li>
</ul>
<img src="http://pictures-by-skylar.oss-cn-shenzhen.aliyuncs.com/img/FH}FFT_6QOXGKBYO$U`QAXV.png" alt="img" style="zoom: 80%;" />

<h3 id="1-2-服务器响应消息"><a href="#1-2-服务器响应消息" class="headerlink" title="1.2 服务器响应消息"></a>1.2 服务器响应消息</h3><ul>
<li>状态行：协议版本 + 状态码 + 状态描述</li>
<li>消息报头</li>
<li>空行</li>
<li>消息报头</li>
</ul>
<h2 id="HTTP-请求方法"><a href="#HTTP-请求方法" class="headerlink" title="HTTP 请求方法"></a>HTTP 请求方法</h2><ul>
<li><p>HTTP 1.0 ：<code>GRT</code>（返回指定页面）, <code>POST</code>（提交数据进行处理请求）, <code>HEAD</code>（仅获取报头）</p>
</li>
<li><p>HTTP 1.1 :  <code>PUT</code>（用我发的东西去取代指定内容）, <code>PATCH</code>（局部更新）,<code>DELETE</code>,  </p>
<p> <code>TRACE</code>（显示服务器收到的请求）, <code>CONNECT</code>，<code>OPTIONS</code>（允许客户端查看服务器的性能）</p>
</li>
</ul>
<h2 id="各版本及其特点"><a href="#各版本及其特点" class="headerlink" title="各版本及其特点"></a>各版本及其特点</h2><ul>
<li><p>HTTP/1.0</p>
<p>采用非连续连接方式，每次浏览器要请求一个文件都要与服务器建立 TCP 连接，当收到响应后就立即关闭连接。为了减少时延，浏览器通常建立多个并行的 TCP 连接同时请求多个对象，但这样会大量占用万维网服务器资源。</p>
</li>
<li><p>HTTP/1.1</p>
<p>非持续连接，在该方式下，万维网在发送响应后仍然保持这条连接，还可以继续交换报文。并布局向在传送同一个页面上引用的对象，而是这些文档都在一个服务器上就行。</p>
<p>可以使用流水线方式工作。</p>
</li>
<li><p>HTTP 报文格式</p>
<p>  请求报文</p>
<p>  <img src="C:%5CUsers%5Chz%5CAppData%5CRoaming%5CTencent%5CUsers%5C1440961573%5CQQ%5CWinTemp%5CRichOle%5C@$DX2%5BGNJIWOER2%5D$ML%25L" alt="img">)M.png)</p>
<p>  响应报文</p>
</li>
</ul>
<h2 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h2><h2 id="POST-和-get"><a href="#POST-和-get" class="headerlink" title="POST 和 get"></a>POST 和 get</h2><h2 id="HTTP-各版本"><a href="#HTTP-各版本" class="headerlink" title="HTTP 各版本"></a>HTTP 各版本</h2><p>HTTP/2</p>
<ul>
<li>二进制传输</li>
<li>多路复用</li>
<li>Header 压缩</li>
<li>服务端 PUSH</li>
</ul>
<p>HTTP/3</p>
<h3 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h3><ul>
<li>多路复用</li>
<li>0-RTT</li>
<li>纠错机制</li>
</ul>
<h2 id="HTTP-报文结构"><a href="#HTTP-报文结构" class="headerlink" title="HTTP 报文结构"></a>HTTP 报文结构</h2><p>状态码和相应的短语</p>
<h3 id="状态码分类"><a href="#状态码分类" class="headerlink" title="状态码分类"></a>状态码分类</h3><ul>
<li><p><code>1**</code> 信息，服务器收到请求，需要请求者继续执行操作<br>（收是收到了，还需要你干点事情）</p>
<ul>
<li>100 continue 等待状态码</li>
<li>101 switching Protocol 切换协议。服务器根据客户端的请求切换协议，如切换到 HTTP 的新版本协议</li>
</ul>
</li>
<li><p><code>2**</code> 某种请求执行成功了</p>
<ul>
<li><strong>200</strong> OK 请求成功，一般用于 GET 或 POST 请求</li>
<li>201 Created</li>
<li>202 Accepted</li>
<li>204 No-content 处理成功但是没有内容返回</li>
<li>206 Partial Content</li>
</ul>
</li>
<li><p><code>3**</code> 重定向状态码，需要附加操作以完成请求</p>
<ul>
<li><strong>301</strong> Moved Permanently 资源或网页被永久转移到其他 URI</li>
<li>302 Found 临时移动，继续使用原有URI</li>
<li>303 See Other 查看其他地址，使用 GET 和 POST 请求查看</li>
<li>304 Not Modified</li>
<li>307 Temporary Redirect 不会从POST变成GET</li>
</ul>
</li>
<li><p><code>4**</code>客户端错误</p>
<ul>
<li>400 Bad Request 请求有语法错误</li>
<li>401 Unauthorized 需要身份认证</li>
<li>402 Forbidden 理解了但拒绝请求</li>
<li><strong>404</strong> Not Found 服务器无法根据客户端的请求找到资源</li>
<li>412 Precondition Fail 客户端请求信息的先决条件错误</li>
<li>417 Expectation Fail 服务器无法满足Expect的请求头信息</li>
</ul>
</li>
<li><p><code>5**</code>服务器错误</p>
<ul>
<li>500 Inernal Server Error 服务器内部出现错误</li>
<li>503 Service Unavailable 超负荷或系统维护</li>
<li>504 Gateway Timeout  网关等待服务器响应超时</li>
</ul>
</li>
</ul>
<p>头部字段</p>
]]></content>
      <tags>
        <tag>NetWork</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTPS</title>
    <url>/2020/07/20/HTTPS/</url>
    <content><![CDATA[<h2 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h2><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2>]]></content>
      <tags>
        <tag>NetWork</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 的原型和继承</title>
    <url>/2020/07/07/class-constructor-prototype/</url>
    <content><![CDATA[<p>发现到现在还是没有很弄明白 JavaScript 的原型和继承，看得晕晕的，决定先总结一下</p>
<a id="more"></a>

<h2 id="先厘清概念"><a href="#先厘清概念" class="headerlink" title="先厘清概念"></a>先厘清概念</h2><ul>
<li><p>构造函数</p>
<p>  构造函数是对象的模板，实例对象的属性和方法可以定义在内部</p>
<p>  可以继承，但是<strong>实例之间无法共享</strong></p>
</li>
<li><p>原型对象（prototype）和 <code>__proto__</code> 属性</p>
<p>  每个<strong>函数</strong>都有一个 prototype 属性，指向一个对象；这个原型对象的所有属性和方法，都能被实例对象共享<br>  每个<strong>对象</strong>都有<code>__proto__</code>属性，指向对应的构造函数的 prototype 属性；但是这个属性是社区创造的，建议使用 <code>Object.getPrototypeOf()</code> 代替</p>
</li>
<li><p>原型链（prototype chain）</p>
<p>  任何对象都可以充当其他对象的原型，原型对象也是对象，也有自己的原型，一层层上溯到 <code>Object.prototype</code>，尽头是 null</p>
</li>
<li><p>constructor 属性</p>
<p>  是 prototype 中的属性，默认指向 prototype 所在的构造函数</p>
<ol>
<li>可以得知某个实例对象是由哪个构造函数产生的</li>
<li>可以从一个实例对象新建另一个实例</li>
</ol>
</li>
</ul>
<h2 id="相互关系"><a href="#相互关系" class="headerlink" title="相互关系"></a>相互关系</h2><h3 id="prototype-constructor-proto属性"><a href="#prototype-constructor-proto属性" class="headerlink" title="prototype, constructor, proto属性"></a>prototype, constructor, <strong>proto</strong>属性</h3><img src="http://pictures-by-skylar.oss-cn-shenzhen.aliyuncs.com/img/image-20200707231813070.png" alt="image-20200707231813070" style="zoom: 50%;" />

<p><a href="https://www.cnblogs.com/cloud-/p/9152761.html" target="_blank" rel="noopener">绕完这个大概就很清楚了</a></p>
<ol>
<li><p>构造出来的函数.<strong>proto</strong> === 构造函数.prototype</p>
</li>
<li><p>prototype 和 constructor 都是一个属性，可以作为一个指针</p>
</li>
<li><p>prototype 对象也是对象，他们也有自己的原型，而所有这些内建对象的源型都指向 Object.prototype</p>
</li>
<li><p>而 object 对象本质也可以看作是由内置构造函数 Function 构造而来，所以其 <strong>proto</strong> 指向 Function.prototype<br> Object，Number，Error等等这些函数都是Function创建的，这些的constructor就是Function，</p>
</li>
<li><p>这个比较迷惑 Object.<strong>proto</strong> === Function.prototype === Function.<strong>proto</strong></p>
</li>
<li><p>存在于原型上的方法是为了方便实例之间共享</p>
</li>
<li><p>建议用 Object.getPrototypeOf 取代 <strong>proto</strong> 属性来获得对象的 [[prototype]]</p>
</li>
</ol>
<h3 id="关于构造函数、prototype属性、ownProperty-和继承的关系"><a href="#关于构造函数、prototype属性、ownProperty-和继承的关系" class="headerlink" title="关于构造函数、prototype属性、ownProperty 和继承的关系"></a>关于构造函数、prototype属性、ownProperty 和继承的关系</h3><ol>
<li><p>new 关键字创建的实例，包括构造函数上和原型上的方法和属性，即两个这部分都继承了<br>// new 方法原理：新建一个空对象，把其原型指向构造函数的 prototype 属性；把空对象赋值给函数内部的this关键字。</p>
</li>
<li><p>Object.creat() 方法则仅仅继承 prototype 属性指向的对象</p>
</li>
<li><p>prototype 属性和构造函数上的方法互相独立，且都是可以继承</p>
</li>
<li><p>区别在于构造函数上的方法和属性在实例之间是不共享的，原型上的是共享的<br> 构造函数上的这些方法通过 this 定义在其自身，hasOwnProperty 方法能返回</p>
</li>
<li><p>prototype 指向的对象才有 constructor 属性，指向正好和 <strong>proto</strong> 相反</p>
</li>
</ol>
<p>参考博客<br><a href="https://www.cnblogs.com/lifeidg/p/10382770.html" target="_blank" rel="noopener">https://www.cnblogs.com/lifeidg/p/10382770.html</a><br>参考教程<br><a href="https://wangdoc.com/javascript/oop/new.html#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95" target="_blank" rel="noopener">new 方法的原理 &amp;&amp; Object.create() 创建实例对象</a></p>
<hr>
<h2 id="ES6-中的-class"><a href="#ES6-中的-class" class="headerlink" title="ES6 中的 class"></a>ES6 中的 class</h2><h3 id="用法-amp-amp-和-ES5-中的类的关系"><a href="#用法-amp-amp-和-ES5-中的类的关系" class="headerlink" title="用法 &amp;&amp; 和 ES5 中的类的关系"></a>用法 &amp;&amp; 和 ES5 中的类的关系</h3><p>取代 es5 中用原型对象构造函数的写法，用 class 作为模板，让原型对象的写法更清晰，本质还是一样的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line"><span class="comment">// 1. constructor 表示构造方法</span></span><br><span class="line"><span class="comment">//【构造函数 --&gt; constructor】</span></span><br><span class="line"><span class="comment">// constructor 方法不同于 constructor 属性</span></span><br><span class="line"><span class="comment">// 就算不显式定义，也会新建一个空的 constructor 方法</span></span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="comment">// 构造方法里的 this 代表实例对象</span></span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// constructor 方法默认返回实例对象 this，你也可以指定成别的</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="comment">// 2. 方法</span></span><br><span class="line">    <span class="comment">// 不需要加 function 关键字</span></span><br><span class="line">    <span class="comment">// 方法之间不需要加逗号分隔</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// static 定义静态方法，即实例不能访问的方法</span></span><br><span class="line">  <span class="keyword">static</span> sayHi()&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"Hi"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类的所有的方法都在prototype中</span></span><br><span class="line"><span class="comment">// 类内部定义的所有方法都是不可枚举的</span></span><br><span class="line"><span class="comment">// 类必须用 new 调用</span></span><br><span class="line"><span class="comment">// 类的实例共享一个原型对象</span></span><br></pre></td></tr></table></figure>

<p>super 关键字</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 作为函数调用时，代表调用父类的构造函数，相当于</span></span><br><span class="line"><span class="keyword">super</span>() --&gt;</span><br><span class="line">A.prototype.constructor.call(<span class="keyword">this</span>)</span><br><span class="line"><span class="comment">// 2. super 作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">super</span>.p())</span><br><span class="line"><span class="comment">// 意为打印 super 对象上的 p() 方法</span></span><br><span class="line"><span class="comment">// 因为是只能调用原型上的方法或属性，定义在父类实上的是不能调用的</span></span><br></pre></td></tr></table></figure>

<h3 id="父类及子类-amp-构造函数和实例之间的关系"><a href="#父类及子类-amp-构造函数和实例之间的关系" class="headerlink" title="父类及子类 &amp; 构造函数和实例之间的关系"></a>父类及子类 &amp; 构造函数和实例之间的关系</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> sayHello()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sayName()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'my name is '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类的继承，所有方法和属性都可以继承，也可以自己添加新的属性和方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="comment">// 通过 this 显式定义在自身的方法通过 constructor 继承</span></span><br><span class="line">    <span class="keyword">constructor</span>(name, age)&#123;</span><br><span class="line">        <span class="keyword">super</span>(name); <span class="comment">// 表示这个属性从父类中继承过来</span></span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    sayAge()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'my age is '</span> + <span class="keyword">this</span>.age);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这才是生成实例</span></span><br><span class="line"><span class="keyword">let</span> parent = <span class="keyword">new</span> Parent(<span class="string">'Parent'</span>);</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child(<span class="string">'Child'</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类上的方法和属性</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'parent: '</span>, parent); <span class="comment">// parent:  Parent &#123;name: "Parent"&#125;</span></span><br><span class="line">Parent.sayHello(); <span class="comment">// hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类的构造函数可以访问到父类的非静态方法</span></span><br><span class="line">parent.sayName(); <span class="comment">// my name is Parent</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类可以访问到父类的所有属性，包括静态属性</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'child: '</span>, child); <span class="comment">// child:  Child &#123;name: "Child", age: 18&#125;</span></span><br><span class="line">Child.sayHello(); <span class="comment">// hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类的实例</span></span><br><span class="line">child.sayName(); <span class="comment">// my name is Child</span></span><br><span class="line">child.sayAge(); <span class="comment">// my age is 18</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="ES6-extends-中的原型关系"><a href="#ES6-extends-中的原型关系" class="headerlink" title="ES6 extends 中的原型关系"></a>ES6 extends 中的原型关系</h3><p>类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</p>
<h4 id="ES5-amp-ES6-中类的继承"><a href="#ES5-amp-ES6-中类的继承" class="headerlink" title="ES5 &amp; ES6 中类的继承"></a>ES5 &amp; ES6 中类的继承</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">两者继承机制不同</span><br><span class="line"></span><br><span class="line">ES5</span><br><span class="line"><span class="number">1.</span> 先创造子类的实例对象<span class="keyword">this</span></span><br><span class="line"><span class="number">2.</span> 再将父类的方法添加到<span class="keyword">this</span>上面--Parent.apply(<span class="keyword">this</span>)</span><br><span class="line">------</span><br><span class="line">    常用方法：</span><br><span class="line">    在子类的构造函数中，调用父类的构造函数</span><br><span class="line">    让子类的原型指向父类的原型</span><br><span class="line"></span><br><span class="line">ES6</span><br><span class="line"><span class="number">1.</span> 先将父类实例对象的属性和方法，加到<span class="keyword">this</span>上面（所以必须先调用<span class="keyword">super</span>方法）</span><br><span class="line"><span class="number">2.</span> 再用子类的构造函数修改<span class="keyword">this</span>。</span><br></pre></td></tr></table></figure>

<h4 id="class-中的继承-——-两条继承链"><a href="#class-中的继承-——-两条继承链" class="headerlink" title="class 中的继承 —— 两条继承链"></a>class 中的继承 —— 两条继承链</h4><p>因为每一个对象都有 <code>__proto__</code> 属性，指向对应的构造函数的 prototype 属性<br>class 同时有 prototype 属性和 <code>__proto__</code> 属性，因此同时有两条原型链</p>
<p>两条继承链：</p>
<ol>
<li>构造器原型链 Child.<strong>proto</strong> === Parent</li>
<li>实例原型链<br>child.<strong>proto</strong> === Child.prototype<br>Child.prototype.<strong>proto</strong> === Parent.protptype<br>parent.<strong>proto</strong> === Parent.prototype</li>
</ol>
<img src="http://pictures-by-skylar.oss-cn-shenzhen.aliyuncs.com/img/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMzI1MzQzMi1kNGMxMmY5MzA3NmVkZTAxLnBuZw.jpg" alt="aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMzI1MzQzMi1kNGMxMmY5MzA3NmVkZTAxLnBuZw" style="zoom: 50%;" />

<p><a href="https://blog.csdn.net/weixin_43312083/article/details/106608505" target="_blank" rel="noopener">参考博客，上图图源</a></p>
<p><a href="https://wangdoc.com/es6/class.html" target="_blank" rel="noopener">阮一峰老师《ECMAScript 6 教程》– class 的基本语法 &amp; class 的继承</a></p>
<hr>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li><code>prototype</code> 、<code>__proto__</code>、<code>constructor</code>之间的关系，他们是如何构成原型链的</li>
<li>构造函数和 <code>prototype</code>指向的对象指向的关系</li>
<li>ES5 &amp; ES6 中类的实现和原理</li>
<li><code>ES6-class</code>中的继承关系 – 两条继承链</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>原型和继承</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络学习笔记</title>
    <url>/2020/07/13/NetWork-Study/</url>
    <content><![CDATA[<p>主要是基于五层原理体系的学习</p>
<a id="more"></a>

<p><strong>目录</strong>：</p>
<!-- TOC -->

<ul>
<li><a href="#概述">概述</a><ul>
<li><a href="#一些术语和概念">一些术语和概念</a></li>
<li><a href="#三种交换方式">三种交换方式</a></li>
<li><a href="#比特速率单位及换算">比特、速率单位及换算</a></li>
<li><a href="#计算机网络体系的分层">计算机网络体系的分层</a></li>
</ul>
</li>
<li><a href="#物理层">物理层</a><ul>
<li><a href="#基本概念们">基本概念们</a></li>
<li><a href="#传输媒体">传输媒体</a></li>
<li><a href="#传输方式">传输方式</a></li>
<li><a href="#编码与调制">编码与调制</a><ul>
<li><a href="#常用编码">常用编码</a></li>
</ul>
</li>
<li><a href="#混合调制">混合调制</a></li>
<li><a href="#信道的极限容量">信道的极限容量</a></li>
</ul>
</li>
<li><a href="#数据链路层">数据链路层</a><ul>
<li><a href="#基本问题">基本问题</a><ul>
<li><a href="#封装成帧">封装成帧</a></li>
<li><a href="#差错检测">差错检测</a></li>
<li><a href="#可靠传输">可靠传输</a></li>
</ul>
</li>
<li><a href="#点对点协议ppppoint-to-point-protocol">点对点协议PPP（point-to-point protocol）</a></li>
<li><a href="#使用广播信道共享式局域网">使用广播信道（共享式局域网）</a><ul>
<li><a href="#媒体接入控制macmedium-access-control">媒体接入控制MAC(Medium Access Control)</a><ul>
<li><a href="#csmacd协议"><code>CSMA/CD</code>协议</a></li>
<li><a href="#csmaca协议"><code>CSMA/CA</code>协议</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#mac-地址ip-地址apr-协议">MAC 地址、IP 地址、APR 协议</a></li>
<li><a href="#交换机">交换机</a></li>
<li><a href="#虚拟局域网-valn-概述">虚拟局域网 VALN 概述</a></li>
</ul>
</li>
<li><a href="#网络层">网络层</a><ul>
<li><a href="#概述-1">概述</a></li>
<li><a href="#网络层提供的两种服务">网络层提供的两种服务</a></li>
<li><a href="#ip地址">IP地址</a><ul>
<li><a href="#ipv4-地址概述">IPv4 地址概述</a></li>
<li><a href="#分类编制的ipv4">分类编制的IPv4</a></li>
<li><a href="#划分子网">划分子网</a></li>
<li><a href="#无分类编址的-ipv4-地址">无分类编址的 IPv4 地址</a></li>
<li><a href="#ipv4-地址的应用规划">IPv4 地址的应用规划</a></li>
</ul>
</li>
<li><a href="#ip-数据报的发送和转发过程">IP 数据报的发送和转发过程</a></li>
<li><a href="#静态路由配置及其可能产生的路由环路问题">静态路由配置及其可能产生的路由环路问题</a></li>
<li><a href="#路由选择协议">路由选择协议</a><ul>
<li><a href="#域内内部网关协议-igp">域内：内部网关协议 IGP</a></li>
<li><a href="#域间外部网关协议-egp边界网关协议-bgp">域间：外部网关协议 EGP（边界网关协议 BGP）</a></li>
</ul>
</li>
<li><a href="#ipv4数据报的首部格式">IPv4数据报的首部格式</a></li>
<li><a href="#网际控制报文协议-icmp">网际控制报文协议 ICMP</a></li>
<li><a href="#虚拟专用网-vpn-和网络地址转换-nat">虚拟专用网 VPN 和网络地址转换 NAT</a></li>
</ul>
</li>
<li><a href="#运输层">运输层</a><ul>
<li><a href="#运输层端口号复用与分用概念">运输层端口号、复用与分用概念</a></li>
<li><a href="#udp-和-tcp-的对比">UDP 和 TCP 的对比</a></li>
<li><a href="#tcp-的流量控制">TCP 的流量控制</a></li>
<li><a href="#tcp-的拥塞控制">TCP 的拥塞控制</a></li>
<li><a href="#tcp-超时重传时间的选择">TCP 超时重传时间的选择</a></li>
<li><a href="#tcp-的运输连接管理">TCP 的运输连接管理</a><ul>
<li><a href="#tcp-连接的建立">TCP 连接的建立</a><ul>
<li><a href="#三报文握手">三报文握手</a></li>
<li><a href="#四报文挥手">四报文挥手</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#tcp-首部格式">TCP 首部格式</a></li>
</ul>
</li>
<li><a href="#应用层">应用层</a><ul>
<li><a href="#客户服务器方式cs和对等方式p2p">客户/服务器方式（C/S）和对等方式（P2P）</a></li>
<li><a href="#动态主机配置-dhcp">动态主机配置 DHCP</a></li>
<li><a href="#域名系统-dns">域名系统 DNS</a></li>
<li><a href="#文件传送协议-ftpfile-transfer-protocol">文件传送协议 FTP（File Transfer Protocol）</a></li>
<li><a href="#电子邮件">电子邮件</a></li>
<li><a href="#万维网">万维网</a><ul>
<li><a href="#url">URL</a></li>
<li><a href="#超文本传输协议-http-">*<em>超文本传输协议 HTTP *</em></a></li>
<li><a href="#cookie">Cookie</a></li>
<li><a href="#万维网缓存和代理服务器">万维网缓存和代理服务器</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="一些术语和概念"><a href="#一些术语和概念" class="headerlink" title="一些术语和概念"></a>一些术语和概念</h3><p><u>计算机网络</u>：一些互相连接的、自治的计算机的集合</p>
<p><u>网络（Network）</u>由若干节点（Node）和链接这些节点的链路（Link）组成</p>
<p><u>互联网</u>：多个网络由路由器互联起来，构成一个覆盖范围更大的网络</p>
<p><u>因特网</u>（Internet）：是一个专有名词，世界上最大的互联网络</p>
<p><u>主机</u>（host）</p>
<p><u>因特网服务提供者 ISP</u>（Internet Service Provider）：国内 ISP 为三大运用商（联通、电信、移动）普通用户向 ISP 缴纳费用就可以获得 IP 地址</p>
<p><u>RFC （Request For Comments）技术文档</u>：因特网在指定及其标准化工作上很大的特点就是面向公众，因特网所有的 RFC 文档都可以从因特网上免费下载，并可以随时提建议。</p>
<hr>
<p><u>广域网</u>（WAN）</p>
<p><u>城域网</u>（MAN）</p>
<p><u>局域网</u>（LAN）</p>
<p><u>个域网</u>（PAN）</p>
<hr>
<p><strong>计算机网络的性能指标</strong>：</p>
<p><u>速率</u>：连接在计算机网络上的主机在数字信道上传送比特的速率（比特率、数据率）</p>
<p><u>带宽</u>：在模拟信号中代表信号所包含的各种不同频率的成分所占据的频率范围；最高数据率</p>
<p><u>吞吐量</u>：单位时间内通过某个网络（或信道、接口）的数据量</p>
<p><u>时延</u>：发送时延、传播时延、处理时延</p>
<p><u>时延带宽积</u>：又称以比特为单位的链路长度，传播时延 * 带宽</p>
<p><u>往返时间</u> RTT（Round-Trip Time）：双向交互一次的时间</p>
<p><u>利用率</u>：信道利用率，网络利用率</p>
<p><u>丢包率</u>：分组丢失率。丢包可能因为分组在传播过程出现误码被节点丢弃；因为网络拥塞在分组交换机被丢弃</p>
<hr>
<p><u>实体</u>：任何可发送或接收信息的硬件或软件进程，对等实体指收发双方层次相同的实体</p>
<p><u>协议</u>：控制两个对等实体进行逻辑通信的规则集合</p>
<p>​    在协议的控制下，对等实体间的逻辑通信使得本层能够向上一层提供服务</p>
<p>​    下面的协议对上面的实体是“透明的” </p>
<p>​    同步：定义收发双方的时序关系；语法，语义</p>
<p><u>服务</u>：</p>
<p>​     - <u>服务访问点</u>：相邻两层的实体交换信息的逻辑接口，</p>
<p>​             - 数据链路层的服务访问点为帧“类型”字段；</p>
<p>​             - 运输层  ==&gt;  “端口号” ； 网络层  ==&gt; IP数据报首部中的“协议字段”</p>
<p>​     - <u>服务原语</u>：上层使用下层所提供的服务必须与下层交换一些命令，这些命令称为 ##</p>
<p>协议数据单元 PDU：对等实体之间传输的数据包称为该层的协议数据单元（横向）</p>
<p>服务数据单元 SDU：层与层之前交换的数据包</p>
<hr>
<h3 id="三种交换方式"><a href="#三种交换方式" class="headerlink" title="三种交换方式"></a>三种交换方式</h3><p>电路交换（Circuit Switching）：建立连接 （分配通信资源）–&gt; 通话（一直占用）–&gt; 释放连接</p>
<p>报文交换（Message Switching）：不对报文进行分割，在路由器中全部储存（不限大小），转发</p>
<p>分组交换（Packet Switching）：</p>
<ul>
<li>发送方构造分组（长度一定，添加首部），发送分组</li>
<li>路由器缓存分组，转发分组（出错只需要重传问题分组）</li>
<li>接收方接受分组，还原报文</li>
</ul>
<h3 id="比特、速率单位及换算"><a href="#比特、速率单位及换算" class="headerlink" title="比特、速率单位及换算"></a>比特、速率单位及换算</h3><p><u>比特</u>（bit）：计算机中数据量的单位，一个比特就是二进制数字中的一个1或0</p>
<p><u>字节</u>（Byte）：1 <em>byte</em> = 8 <em>bit</em></p>
<p>比特单位（数据量）：<em>KB</em> = 2 <sup>10</sup> <em>B</em>，<em>MB</em> = 2 <sup>20</sup> <em>B</em>，<em>GB</em> = 2 <sup>30</sup> <em>B</em>，<em>TB</em> = 2 <sup>40</sup> <em>B</em></p>
<p>速率（数据率）：<em>bits</em>/s (<em>bps<em>，</em>b/s</em> )</p>
<p>​    <em>KB</em> = 10 <sup>3</sup> <em>bps<em>，</em>KB</em> = 10 <sup>6</sup> <em>bps<em>，</em>KB</em> = 10 <sup>9</sup> <em>bps<em>，</em>KB</em> = 10 <sup>12</sup> <em>bps</em></p>
<h3 id="计算机网络体系的分层"><a href="#计算机网络体系的分层" class="headerlink" title="计算机网络体系的分层"></a>计算机网络体系的分层</h3><img src="http://pictures-by-skylar.oss-cn-shenzhen.aliyuncs.com/img/image-20200713173424378.png" alt="image-20200713173424378" style="zoom:80%;" />

<table>
<thead>
<tr>
<th align="left">层级</th>
<th align="left">任务</th>
<th align="left">主要协议</th>
<th align="left">数据包</th>
</tr>
</thead>
<tbody><tr>
<td align="left">物理层</td>
<td align="left">解决何种信号进行传输比特的问题</td>
<td align="left"><code>HTTP</code>，<code>SMTP</code></td>
<td align="left">报文<code>messege</code></td>
</tr>
<tr>
<td align="left">数据链路层</td>
<td align="left">解决分组在一个网络（一段链路）上传输的问题</td>
<td align="left"><code>TCP</code>,<code>UDP</code></td>
<td align="left">TCP数据包，UDP用户数据报文段</td>
</tr>
<tr>
<td align="left">网络层</td>
<td align="left">分组在多个网络传输（路由）的问题</td>
<td align="left"><code>IP</code></td>
<td align="left">IP数据报或分组</td>
</tr>
<tr>
<td align="left">运输层</td>
<td align="left">解决进程之间基于网络的通信问题</td>
<td align="left">传统以太网 <code>CSMA/CD</code></td>
<td align="left">帧</td>
</tr>
<tr>
<td align="left">应用层</td>
<td align="left">解决通过应用进程的交互来实现特点网络应用的问题</td>
<td align="left">曼彻斯特编码</td>
<td align="left">比特流</td>
</tr>
</tbody></table>
<p>对OSI 七层体系结构还有：</p>
<p><u>应用层</u>：通信双方信息表示问题：数据格式化，文本压缩、解密等</p>
<p><u>会话层</u>：进程之间的会话</p>
<p>😄😂</p>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><h3 id="基本概念们"><a href="#基本概念们" class="headerlink" title="基本概念们"></a>基本概念们</h3><p>物理层考虑怎样才能在连接各种计算机的传输媒体上传输数据比特流，需要考虑的包括</p>
<p>机械特性：关于接口所用接线器</p>
<p>电气特性：电压</p>
<p>功能特性：某一电平的电压表示何种意义</p>
<p>过程特性：对于不同功能的各种可能事件的出现顺序</p>
<h3 id="传输媒体"><a href="#传输媒体" class="headerlink" title="传输媒体"></a>传输媒体</h3><p>导引性传输媒体：同轴电缆（基本不用了）、双绞线、光纤（损耗小容量大）、电力线</p>
<p>非导引型传输媒体：无线电波、微波、红外线（✖）、可见光</p>
<h3 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h3><p>串行传输：远距离传输，如计算机网络</p>
<p>并行传输：近距离传输，CPU &lt;===&gt; 接口 </p>
<p>同步传输：收发双方时钟同步的方法；外同步是在收发双方之间添加一条单独的时钟信号线，内同步是将时钟同步信号编码到发送数据中一起运输（如曼彻斯特编码）</p>
<p>异步传输：字节之间异步，每个比特之间仍是同步的</p>
<p>单向通信（单工）：单向</p>
<p>双向交替通信（半双工）：不同时</p>
<p>双向同时通信（全双工)</p>
<hr>
<h3 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h3><p>码元：在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形（构成信号的一个单元，比特 0 和比特 1 用不同波形表示）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">消息（传送数据的实体） --&gt; 数据（电磁形式）--&gt; 信号 --&gt; 基带信号</span><br><span class="line">|--- 数字基带信号</span><br><span class="line">	|--- 编码 ---&gt; 数字信道 ===&gt; 以太网（曼彻斯特编码）</span><br><span class="line">	|--- 调制 ---&gt; 模拟信道 ===&gt; WIFI（CCK/DSSS/OFDM调制）</span><br><span class="line">|--- 模拟基带信号</span><br><span class="line">	|--- 编码 ---&gt; 数字信道 ===&gt; 音频信号进行编码的脉调制 PCM</span><br><span class="line">	|--- 调制 ---&gt; 模拟信道 ===&gt; 语音数据加载到模拟的载波信号中传输</span><br><span class="line">--&gt; 传输媒体（发送信道，接收信道）</span><br></pre></td></tr></table></figure>

<h4 id="常用编码"><a href="#常用编码" class="headerlink" title="常用编码"></a>常用编码</h4><p>不归零编码：需要额外一根传输线来传输时钟，浪费</p>
<p>归零编码：自同步，每个码元传输完毕后归零，浪费数据带宽</p>
<p>曼彻斯特编码：码元中间时刻的跳变，既表示始终又表示数据</p>
<p>差分曼彻斯特编码：跳变仅代表时钟；码元开始处电平是否变化表示数据；更适合较高速的传输速率</p>
<h3 id="混合调制"><a href="#混合调制" class="headerlink" title="混合调制"></a>混合调制</h3><p>频率（调频，FM），相位（PM），振幅（调幅，AM）</p>
<p>相位 + 振幅 ==&gt; 正交振幅调制  QAM</p>
<hr>
<h3 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h3><p>奈氏准则：在假定的理想条件下，为了避免码间串扰，码元传输速率是有上限的</p>
<p>香农公式：带宽受限且有高斯白噪声干扰的信道的极限信息传输速率</p>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>链路：一个节点到相邻节点的一段物理线路，中间没有任何其他交换节点</p>
<p>数据链路：把实现通信协议的硬件和软件加到链路上，就构成了数据链路</p>
<p>帧：是数据链路层传输和处理数据的单位</p>
<p>使用点对点信道的数据链路层的重要问题：</p>
<ul>
<li>封装成帧</li>
<li>差错检测</li>
<li>可靠传输</li>
</ul>
<p>除此之外，使用广播信道（共享式局域网）</p>
<p>​共享式以太网的媒体接入控制协议 CSMA/CD</p>
<p>​802.11局域网的媒体接入控制</p>
<p>交换式局域网</p>
<p>​网桥和交换机的工作原理</p>
<h3 id="基本问题"><a href="#基本问题" class="headerlink" title="基本问题"></a>基本问题</h3><h4 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h4><p>指数据链路层给上层交付的协议数据单元添加<strong>帧头和帧尾</strong>使之变成帧，</p>
<p>帧头和帧尾中包含有重要的控制信息，如帧定界符——便于从接收的比特流中提取出帧</p>
<p>以太网的Mac帧的帧头和帧尾不包含帧定界符，而是通过在物理层添加前导码来定界</p>
<p><strong>透明传输</strong>：即数据链路层对其上层交付的内容没有限制</p>
<p>对 flag 和 ESC 要进行转义（面向字节）；零比特填充法（面向比特）</p>
<p><strong>最大传送单元</strong><code>MTU</code>（Maximum Transfer Unit）：为了提高传输效率，应使帧尽量长，但是老绿道差错控制等因素，每一种数据链路层协议都规定了帧数据部分的最大长度。</p>
<h4 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h4><p>比特差错：比特 0 / 1差错</p>
<p>误码率：Bit Error Rate</p>
<p>差错检测码：检测数据在传输过程中是否产生了比特差错</p>
<p><strong>检错方法</strong></p>
<ul>
<li><p>奇偶校验：在待发送的数据后面添加1位奇偶校验码，使得整个数据中“1”的个数为奇数（奇校验）或偶数，检测得到的数据中“1”的奇偶性有无发生变化</p>
</li>
<li><p>循环冗余校验CRC（Cyclic Redundancy Check）</p>
</li>
</ul>
<p>约定生成多项式<code>G(x)</code> ==&gt; 待发送数据和生成多项式计算差错检测码（冗余码）==&gt; 接收方检测</p>
<p>检错能力好，容易通过硬件实现，广泛应用于数据链路层</p>
<p>注意：只能检测出差错，无法定位差错，因此无法纠正错误；通常用<strong>检测重传</strong>方式来纠正传输中的错误</p>
<h4 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h4><p>用差错检技术检测是否存在误码如何处理？</p>
<p>不可靠传输：仅仅丢弃有误码的帧</p>
<p>可靠传输：想办法实现发送端传输什么，接收端就收到什么</p>
<p>一般使用：有线链路误码率较低，不要求数据链路层的可靠传输；无线则相反</p>
<p>传输差错类型：比特差错（数据链路层）、分组丢失、分组失序、分组重复</p>
<hr>
<p><strong>可靠传输的实现机制</strong>（适用于各层）</p>
<p><strong>停止-等待协议</strong>SW（Stop-and-Wait）</p>
<p>W<sub>T</sub> = W<sub>R</sub> =1</p>
<p>机制：</p>
<ul>
<li><p>一步一步走，一个data，回复一个 ACK 或 NAK</p>
</li>
<li><p>需要给分组编号(0/1) –&gt; 是否重复</p>
</li>
<li><p>超时重传 –&gt; 不要一直在等</p>
</li>
</ul>
<p>缺点：信道利用率低，要是超时重传了更低</p>
<p><strong>回退 N 帧协议</strong> GBN</p>
<p>1 &lt; W<sub>T</sub> &lt;= 2<sup>n</sup> - 1</p>
<p>机制：</p>
<ul>
<li><p>可以流水线式传输，可以 <code>ACKn</code> 累积确认</p>
</li>
<li><p>收到重复确认就知道已发送的数据分组有误，重传</p>
</li>
<li><p>但是一旦中间出现差错，需要丢弃已经接收到的未按序到达的部分，通信质量不好时信道利用率并不优于 SW 协议</p>
</li>
<li><p>若W<sub>T</sub> &gt; 2<sup>n</sup> - 1 接收方无法分辨新旧数据分组</p>
</li>
</ul>
<p><strong>选择重传协议 SR</strong>（Selective Request）</p>
<p>接收窗口大于 1，先接受失序到达但无误码并且序号落在接收窗口的数据分组，收齐了再一起交到上层，接收窗口滑动，为了让发送方仅重传差错的数据分组，不能再累积确认，应该逐一确认</p>
<hr>
<h3 id="点对点协议PPP（point-to-point-protocol）"><a href="#点对点协议PPP（point-to-point-protocol）" class="headerlink" title="点对点协议PPP（point-to-point protocol）"></a>点对点协议PPP（point-to-point protocol）</h3><p>PPP 协议<u>为在点对点链路传输的各种协议</u>数据报提供了<u>一个标准方法</u>，由以下三部分</p>
<ul>
<li><p>对各协议数据报的<strong>封装方法</strong></p>
<p><strong>帧格式</strong>：</p>
<img src="http://pictures-by-skylar.oss-cn-shenzhen.aliyuncs.com/img/FCA17D68EE20F333887C7B07D2B2EE86.png" alt="FCA17D68EE20F333887C7B07D2B2EE86" style="zoom:67%;" />

<p>F：Flag 字段，定界符，16进制，取值为 0×7E</p>
<p>A：Addess 字段，0×FF，预留</p>
<p>C：Control，0×03，预留</p>
<p>P：Protocol：指明帧交付哪个协议处理，如0×0021 ==&gt; 帧的数据部分是 IP 数据报</p>
<p>​    0×C021 ==&gt; LCP 分组；0×8021 ==&gt; NCP 分组</p>
<p>FCS（Frame Check Sequence）：帧检测序列，用 CRC 计算出的校验位</p>
<p><strong>透明传输</strong>：</p>
<p>面向字节：7E ==&gt; (7D,5E)；转移符7D ===&gt; (7D,5D)</p>
<p>面向比特：五个连续1插入一个比特0</p>
<p><strong>差错检测</strong>：向上提供不可靠传输服务</p>
</li>
<li><p>链路控制协议 LCP：用于建立、配置以及测试数据链路的连接（向下面向字节的异步链路/ 同步链路）</p>
</li>
<li><p>一套网络控制协议NCPs：（向上面向网络层，如TCP/IP中的 IP）</p>
</li>
</ul>
<p>工作模式：</p>
<p><img src="http://pictures-by-skylar.oss-cn-shenzhen.aliyuncs.com/img/E2E3E4ECF15689664929B81007AEF7C5.png" alt="img"></p>
<hr>
<h3 id="使用广播信道（共享式局域网）"><a href="#使用广播信道（共享式局域网）" class="headerlink" title="使用广播信道（共享式局域网）"></a>使用广播信道（共享式局域网）</h3><p>共享信道除了需要考虑以上三个基本问题之外，还需要考虑如何协调<u>多个发送和接收站点</u>对<u>一个共享媒体传输</u>的占用——一个信道多个活动的分配，所以需要进行<strong>媒体接入控制</strong></p>
<h4 id="媒体接入控制MAC-Medium-Access-Control"><a href="#媒体接入控制MAC-Medium-Access-Control" class="headerlink" title="媒体接入控制MAC(Medium Access Control)"></a>媒体接入控制MAC(Medium Access Control)</h4><p>随着技术的发展，交换技术的成熟和成本的降低，具有更高性能的使用点对链路和链路层交换机技的交换式局域网在有线领域已经完全取代了共享式局域网，但由于无线信道的广播天性，无限局域网仍然使用共享式局域网</p>
<p><strong>静态划分信道</strong>：预先固定分配好信道，不够灵活，对突发性数据传输利用率低，通常用与物理层</p>
<p>复用：通过一条物理线路同时传输多路用户的信号</p>
<p>频分复用FDM：同时占用不同的频带资源并行通信</p>
<p>时分复用TDM</p>
<p>波分复用WDM</p>
<p><u>码分多址 CDMA</u>（Code Division Multiple Access）</p>
<p>各用户挑选不同的码型，可以用在同样的时间使用同样的频带进行通信，不会造成干扰</p>
<p>在<code>CDMA</code>中，每一个比特时间再划分为<code>m</code>个短的间隔，称为<u>码片</u> ，使用 CDMA 的每一个站被指派一个唯一的m bit码片序列……</p>
<hr>
<p><strong>动态接入控制</strong>：主要接入方为随机接入：所有站点通过竞争，随机在信道上发送数据，如果产生了冲突，则双方均发送失败；通过协议来解决冲突之后应该如何尽快回复（共享式以太网就是采用随机接入）</p>
<p><u>载波监听多址接入/碰撞检测</u>（<strong>总线局域网</strong>使用） <code>CSMA/CD</code>（Carrier Sense Multiple Access/ Collision Detection）</p>
<ul>
<li><p>多址接入 <code>MA</code></p>
<p>分布：多个站连接在一条总线上，竞争使用总线</p>
</li>
<li><p>载波监听 <code>CS</code></p>
<p>发送：先听后发，要发送帧时要先检测一下总线上是否有其他站点在发送帧——检测到总线<u>空闲96比特</u>则发送这个帧</p>
</li>
<li><p>碰撞检测 <code>CD</code></p>
<p>冲突：一边发送一遍检测碰撞，一旦碰撞立即停止发送；退避后重发</p>
<p>强化碰撞：还继续发送 32/48bit 的人为干扰信号，以便有更多碰撞信号使所有站点检测出来</p>
</li>
</ul>
<h5 id="CSMA-CD协议"><a href="#CSMA-CD协议" class="headerlink" title="CSMA/CD协议"></a><code>CSMA/CD</code>协议</h5><ul>
<li><p>争用期（碰撞窗口）</p>
<p>主机最多经过2τ（RTT）时长就可以检测除本次是否发生了碰撞</p>
<p>以太网帧发送的主机多，往返时延大，碰撞易发生，所以不要太长</p>
</li>
<li><p>最小帧长</p>
<p>可以保证在发送完毕之前就检测到该帧的发送过程中是否遭遇碰撞</p>
<p>以太网规定最小帧长为64字节</p>
</li>
<li><p>最大帧长</p>
</li>
<li><p>截断二进制指数<strong>退避算法</strong></p>
<p>退避时间 = 基本退避时间（争用期时间） * 随机数</p>
<p>重传 16次还不成功就丢弃</p>
</li>
</ul>
<hr>
<h5 id="CSMA-CA协议"><a href="#CSMA-CA协议" class="headerlink" title="CSMA/CA协议"></a><code>CSMA/CA</code>协议</h5><p><u>载波监听多址接入/碰撞避免</u>（<strong>无线局域网</strong>） <code>CSMA/CA</code>（Carrier Sense Multiple Access/ Collision Avoidance）</p>
<p>是 <code>IEEE802.11</code>无线局域网采用的无线信道访问控制协议，因为无线局域网难以实现碰撞检测（传播强度减弱、隐蔽站问题）</p>
<ul>
<li><p>帧间间隔 <code>IFS</code>：802.11标准规定所有的站点必须持续检测到信道空闲一段时间后才能发送帧</p>
<ul>
<li>短帧帧间间隔<code>SIFS</code>：用于分隔属于一次对话的各帧</li>
<li><code>DCF</code>帧间间隔<code>DIFS</code>：在 DCF 方式中发送数据和管理帧，信道由忙转空闲后经过 DIFS 时间后还要退避一段时间后才能使用信道（为了尽可能地避免碰撞）</li>
<li>在实行 CSMA/CD 的时候还是用 停止等待协议（一个个收发）</li>
</ul>
</li>
<li><p>802.11 标准的信道预约和虚拟载波监听</p>
<ul>
<li><code>RTS</code>（Request To Send）发送请求：一个短帧，包括源地址、目的地址和这次通信所需要的时间（MAC 帧首部有一个持续期字段）</li>
<li>允许发送<code>CTS</code> (Clear To Send)：包括源地址、持续时间；</li>
<li>虚拟载波监听：站点只要监听到 RTS 帧、CTS 帧、数据帧的任何一个，就知道信道被占用的持续时间，不需要真正监听到信道上的信号，因此可以键少隐蔽站带来的碰撞问题</li>
</ul>
</li>
</ul>
<h3 id="MAC-地址、IP-地址、APR-协议"><a href="#MAC-地址、IP-地址、APR-协议" class="headerlink" title="MAC 地址、IP 地址、APR 协议"></a>MAC 地址、IP 地址、APR 协议</h3><p>（交换式局域网）</p>
<p><strong>MAC 地址</strong>：是以太网的 MAC 子层所示用的地址（数据链路层）</p>
<ul>
<li>是什么<pre><code>- 同一广播信道上的两个主机通信需要；网络上各接口的唯一的标识
   - 主机发送的**帧**中的地址，由于媒体接入控制——Media Access Control
- 一般被固定在网卡的电可擦可编程只读存储器 EEPROM 中（硬件地址/物理地址）
- 决定单播还是多播？
- 数据链路层首部标记 MAC 地址</code></pre></li>
</ul>
<ul>
<li><p>组成和分类</p>
<ul>
<li><p>&amp;nbsp|第一字节第0位|第一位</p>
<p>0|单播|全球管理</p>
<p>1|多播|本地管理</p>
</li>
<li><p>广播 MAC 地址：FF-FF-FF-FF-FF-FF</p>
</li>
<li><p>多播地址：第一个字节的最小比特为为1</p>
</li>
<li><p>随机 MAC 地址：隐私</p>
</li>
</ul>
</li>
</ul>
<p><strong>IP 地址</strong>：是 TCP/IP 体系结构的网际层所使用的地址</p>
<ul>
<li><p>是什么</p>
<ul>
<li>是<strong>因特网上</strong>主机和路由器所使用的地址，用于网络编号（因特网上各网络）和主机编号（不同的主机或路由器各接口）</li>
<li>网络层首部需要标记 IP 地址</li>
</ul>
</li>
<li><p><strong>数据包转发</strong>：转发时源IP 地址和目的 IP 地址是不变的；而源 MAC 地址和目的 MAC 地址是随逐个网络（不用的路由器）改变。所以要正常转发必须有把那知道 IP 地址和 MAC 地址的对应关系</p>
</li>
</ul>
<p><strong>ARP 协议</strong>：属于 TCP/IP 体系结构的网际层。</p>
<ul>
<li><p>是什么 </p>
<ul>
<li>地址解析协议 APR</li>
<li>已知设备分配到的 IP 地址，使用 ARP 协议可以获得设备的 MAC 地址。</li>
<li>ARP 高速缓存</li>
<li><strong>不能跨网络使用 ARP</strong></li>
</ul>
</li>
<li><p>ARP 请求报文（广播发送）</p>
<ul>
<li>我想知道 IP 地址为 *** 的主机的 MAC 地址</li>
<li>目的主机接收请求报文，记录来源的 IP 地址和 MAC 地址，向来源主机发送  ARP自己的 MAC 地址</li>
<li>把得到的 MAC 地址记录到自己的 ARP 告诉缓存中</li>
</ul>
</li>
<li><p>ARP 高速缓存条目分类</p>
<ul>
<li>动态：自动获取，生命周期默认两分钟</li>
<li>静态：手工设置</li>
</ul>
</li>
</ul>
<h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p><strong>集线器</strong></p>
<ul>
<li><p>星型以太网，仍然是一个总线网，使用 CSMA/CD 协议</p>
</li>
<li><p>工作在物理层</p>
</li>
<li><p>互联成更大的总线型以太网；更大的碰撞域（冲突域）</p>
</li>
</ul>
<p><strong>交换机</strong></p>
<ul>
<li>多个接口，每个接口都能与一台主机或者以太网交换机相连，全双工方式</li>
<li>并行，同时通信，无碰撞</li>
<li>工作在数据链路层（也包括物理层）：收到帧后再<strong>帧交换表</strong>中查找 MAC 地址对应的接口号，然后转发</li>
<li>即插即用，帧交换表会通过自学习算法自动建立起来的</li>
<li>扩大广播域，不会扩大碰撞域（VLAN 除外）</li>
</ul>
<p><strong>交换机自学习和转发帧</strong></p>
<p>（假设个网络中其他个主机的 MAC 地址，无需进行 ARP）</p>
<ul>
<li>不知道的时候：洪泛发送，登记；其他交换机也记录发送主机的来源接口</li>
<li>知道的时候：明确转发，其他人收不到</li>
<li>有效时间，到期删除：接口对应的主机换了；主机的网卡换了</li>
</ul>
<hr>
<p><strong>以太网交换机的生成树协议 STP</strong></p>
<p>提高以太网的可靠性——添加<strong>冗余链路</strong></p>
<p>以太网生成树协议：可以自动计算并构建一个逻辑上没有环路的网络，其逻辑拓扑结构必须是树形的、连通整个网络的</p>
<hr>
<h3 id="虚拟局域网-VALN-概述"><a href="#虚拟局域网-VALN-概述" class="headerlink" title="虚拟局域网 VALN 概述"></a>虚拟局域网 VALN 概述</h3><p>以太网交换机工作在数据链路层（包括物理层），而使用以太网交换机互联的交换式以太网所有站点都属于一个广播域，但是这样会带来”广播风暴”、为以维护、安全隐患等问题；而 TCP/ IP 协议栈很多协议都会使用广播（ARP、路由信息协议 RIP 、动态主机配置协议 DHCP）</p>
<p><strong>分隔广播域</strong></p>
<p>路由器分隔 &amp; VLAN</p>
<p><strong>VLAN</strong>（Virtual Local Area Network）:</p>
<ul>
<li>是什么：将局域网内设备按<u>共同需求</u>划分成逻辑组的一种技术</li>
<li>实现机制：</li>
</ul>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>网络层的主要任务是实现网络互连，进而实现数据包在<strong>各网络之间</strong>的传输</p>
<p>要实现网络层的任务，需要解决的问题：</p>
<ul>
<li>网络向运输层提供什么样的服务（可靠传输还是不可靠）</li>
<li>网络寻址问题</li>
<li>路由选择问题</li>
</ul>
<p><strong>因特网、网际层和 TCP/IP 协议栈</strong></p>
<p><u>因特网</u>是全球用户最多的互联网，它使用 <u>TCP/IP 协议栈</u></p>
<p>TCP/IP 协议栈的网络层使用<u>网际协议 IP</u>，因此在 TCP/IP 协议栈中网络层称为<u>网际层</u></p>
<hr>
<h3 id="网络层提供的两种服务"><a href="#网络层提供的两种服务" class="headerlink" title="网络层提供的两种服务"></a>网络层提供的两种服务</h3><p><strong>面向连接的虚电路服务</strong></p>
<ul>
<li>可靠通信由网络来保证</li>
<li>必须建立网络层的连接——虚电路 VC（Virtual Circuit），通信双方沿着已经建立的蓄电库大宋分组；结束之后释放虚电路</li>
<li>只需要在建立连接的时候使用目的主机的地址，之后只需要分隔分组的首部携带一条虚电路的编号</li>
<li>这种通信方式如果再使用可靠传输的网络协议，就可以使发送的分组最终正确到达接受方（按序、不丢失、不重复）</li>
<li>很多广域分组交换网都是用面向连接的虚电路服务</li>
</ul>
<p><strong>无连接的数据报服务</strong></p>
<ul>
<li>可靠通信由用户主机保证</li>
<li>不需要建立网络层的连接</li>
<li>每个分组可以走不同的路径</li>
<li>每个分组的首部必须携带目的的主机的完整地址</li>
<li>可能误码、丢失、重复和失序</li>
<li>由于网络本身不提供端到端的可靠传输服务，使路由器可以做得比较简单</li>
<li>因特网使用了这种设计思想，将复杂的网络处理功能之余因特网的边缘（用户主机及其内部的运输层），而将相对简单的尽最大努力的分组交付功能置于因特网核心</li>
</ul>
<p><img src="http://pictures-by-skylar.oss-cn-shenzhen.aliyuncs.com/img/%60$9FO4GU0%5D41_69H0ONLIP2.png" alt="img"></p>
<p>TCP/IP 体系结构的因特网的网际层提供的是简单灵活、无连接的、尽最大努力交的数据报服务，本章一下内容主要围绕网际层如何传送 IP 数据报这个主题进行讨论</p>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><h4 id="IPv4-地址概述"><a href="#IPv4-地址概述" class="headerlink" title="IPv4 地址概述"></a>IPv4 地址概述</h4><p>IPv4 地址是因特网上每一台主机（或路由器）的每一个接口分配在全世界范围内唯一的32比特标识符。32 比特不方便阅读，因此采用<strong>点分十进制表示方法</strong>以便用户使用。</p>
<h4 id="分类编制的IPv4"><a href="#分类编制的IPv4" class="headerlink" title="分类编制的IPv4"></a>分类编制的IPv4</h4><table>
<thead>
<tr>
<th align="center">分类</th>
<th align="center">网络号位数</th>
<th align="center">开头位</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A类</td>
<td align="center">8位</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">B 类</td>
<td align="center">16位</td>
<td align="center">10</td>
</tr>
<tr>
<td align="center">C类</td>
<td align="center">24位</td>
<td align="center">110</td>
</tr>
</tbody></table>
<p>只有 A 、B、C类地址可以分配。主机号全 0 的是网络地址，主机号全 1 的是广播地址，不分配。</p>
<p>这几类的最小网络号 0 保留不指派，最大网络号做为本地换回测试地址不指派</p>
<h4 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h4><p>是什么：借用主机号的一部分来作子网号，就可以把网络号进一步划分成更多的部分，这种方法称为<strong>划分子网</strong>的方法，可以来充分利用原有网络号中的 IP 地址。如果我们反过来想知道分类地址中主机号有多少比特被当做子网号了，可以通过<strong>子网掩码得知</strong>。</p>
<p>子网掩码表示规则：连续比特 1 来表示对应网络号和子网号，0 表示主机号</p>
<h4 id="无分类编址的-IPv4-地址"><a href="#无分类编址的-IPv4-地址" class="headerlink" title="无分类编址的 IPv4 地址"></a>无分类编址的 IPv4 地址</h4><p>CIDR 使用“斜线记法”（CIDR法）：在 IPv4 地址后面加上<code>/</code>并写上网络前缀所占的比特数量</p>
<p>那么网络前缀相同的连续 IP 地址可以组成一个“ CIDR 地址块”</p>
<p>通过路由聚合的方法，网络前缀越长，地址块越小越优先</p>
<h4 id="IPv4-地址的应用规划"><a href="#IPv4-地址的应用规划" class="headerlink" title="IPv4 地址的应用规划"></a>IPv4 地址的应用规划</h4><p>定长子网掩码 FLSM</p>
<p>变长子网掩码 VLSM</p>
<h3 id="IP-数据报的发送和转发过程"><a href="#IP-数据报的发送和转发过程" class="headerlink" title="IP 数据报的发送和转发过程"></a>IP 数据报的发送和转发过程</h3><p>主机发送：判断是否同一网络，是就直接交付，不是就交给默认网关</p>
<p>路由转发：检查首部是否出错；根据 IP 数据目的地址在路由表中查找匹配的条目</p>
<h3 id="静态路由配置及其可能产生的路由环路问题"><a href="#静态路由配置及其可能产生的路由环路问题" class="headerlink" title="静态路由配置及其可能产生的路由环路问题"></a>静态路由配置及其可能产生的路由环路问题</h3><p>配置错误导致套娃</p>
<h3 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h3><p>动态路由选择是路由器通过路由选择协议自动获取路由信息</p>
<p>特点：自适应；分布式（路由器之间交换路由信息）；分层次（将以特网划分成许多较小的自制系统AS）</p>
<img src="http://pictures-by-skylar.oss-cn-shenzhen.aliyuncs.com/img/00C9A8E8FB3D41751D60281A2B86A1ED.png" alt="img" style="zoom:50%;" />

<h4 id="域内：内部网关协议-IGP"><a href="#域内：内部网关协议-IGP" class="headerlink" title="域内：内部网关协议 IGP"></a>域内：内部网关协议 IGP</h4><ul>
<li><p><strong>RIP</strong> (Rountine Information Protocol) 是 IGP 中最先广泛应用的协议之一</p>
<ul>
<li>选择依据：AS 内每一个路由器都要维护从他自己到 AS 内其他每日一个网络的距离记录，RIP 用跳数作为量度来衡量到达目的网络的距离</li>
<li>限制：允许一条路径最多包含15 个路由器，距离等于16相当于不可达</li>
<li>选择：优先短路径，多条“距离”相等的路由时，进行<u>等价负载均衡</u></li>
<li>要点：仅和相邻的路由器交换路由表；周期性交换</li>
<li>工作过程<ul>
<li>开始时只知道自己和直连网络的距离位移</li>
<li>和相邻的路由器周期性交换并更新（没有的加上，有更短的更新，相同的等价负载均衡）路由信息</li>
<li>最后每个路由器都知道本 AS 内个网络的嘴短距离和下一跳地址（<strong>收敛</strong>）</li>
</ul>
</li>
<li>坏消息传的慢（路由环路）：当某路由直连的网络发生故障时，其路由表中到故障网络的跳数就会变成16，此时其路由表传输会慢于其他路由表，因此在周期交换中“被谣言误导”，经过多次交换后才渐渐收敛。</li>
</ul>
</li>
<li><p><strong>OSPF</strong>(Open Shorter Path First) 开放最短路径优先</p>
<ul>
<li>选择依据：基于链路状态（本路由器和那些路由器相连，及相应链路的代价——费用、距离、时延、带宽等），通过最短路径算法<strong>SPF</strong>计算，从算法上保证了不会产生路由环路</li>
<li>交互“问候（Hello）分组”，建立和维护邻里关系：发送周期为10s， 40s还不收到就认为该邻居路由不可达</li>
<li>每个路由都会产生链路状态通告<strong>LSA</strong> ，封装在链路状态更新分组<strong>LSU</strong> 中，洪泛发送——包含直连网络和邻居路由器的链路状态信息；而 <code>LUA</code>存储在<strong>链路状态数据库 LSDB</strong></li>
<li>在多点接入网络中：选举指定路由器和备用指定路由器，大家都和他们建立连接</li>
</ul>
</li>
</ul>
<h4 id="域间：外部网关协议-EGP（边界网关协议-BGP）"><a href="#域间：外部网关协议-EGP（边界网关协议-BGP）" class="headerlink" title="域间：外部网关协议 EGP（边界网关协议 BGP）"></a>域间：外部网关协议 EGP（边界网关协议 BGP）</h4><ul>
<li>BGP 致力于寻找一条能够到达且比较好的路由，而非寻找最佳路由</li>
</ul>
<h3 id="IPv4数据报的首部格式"><a href="#IPv4数据报的首部格式" class="headerlink" title="IPv4数据报的首部格式"></a>IPv4数据报的首部格式</h3><h3 id="网际控制报文协议-ICMP"><a href="#网际控制报文协议-ICMP" class="headerlink" title="网际控制报文协议 ICMP"></a>网际控制报文协议 ICMP</h3><p>ICMP（Internet Control Message Protocol）</p>
<p>干什么的：在网际层使用，被封装在 IP 数据报中发送，主机或路由器使用 ICMP 来发送<strong>差错报告报文</strong>和<strong>询问报文</strong>，以提高 IP 数据报成功交付的机会</p>
<p><strong>差错报文</strong></p>
<ul>
<li><p>类型</p>
<ul>
<li>终点不可达：路由器或主机不能交付数据报</li>
<li>源点抑制：因拥塞而丢弃，让主机放慢发送速率</li>
<li>时间超过：生存字段为 0 时</li>
<li>参数问题：出现误码</li>
<li>改变路由（重定向）：有更好的路由</li>
</ul>
</li>
<li><p>以下类型不发送差错报文了</p>
<ul>
<li>对 ICMP 自己的差错</li>
<li>对第一个分片的数据报文的所欲后续数据报片都不发送</li>
<li>对多播地址的数据报</li>
<li>特殊地址的数据报</li>
</ul>
</li>
</ul>
<p><strong>询问报文</strong></p>
<ul>
<li>类型<ul>
<li>回复请求和回答：测试是否可达及其状态</li>
<li>时间戳请求和回答：测试同步和测量时间</li>
</ul>
</li>
</ul>
<p><strong>ICMP 报文应用</strong></p>
<ul>
<li>分组网间探测 PING ：用来测试主机或路由器的联通性；是使用网际层的 ICMP 来会送请求和回答报文</li>
<li>跟踪路由 traceroute：测试 IP 数据报到源主机到达目的主机需要经过哪些路由器；在 windows 系统中，使用 tracer 命令，使用 ICMP 会送请求、回答和差错报告报文</li>
</ul>
<hr>
<h3 id="虚拟专用网-VPN-和网络地址转换-NAT"><a href="#虚拟专用网-VPN-和网络地址转换-NAT" class="headerlink" title="虚拟专用网 VPN 和网络地址转换 NAT"></a>虚拟专用网 VPN 和网络地址转换 NAT</h3><p><strong>VPN</strong> (Virtual Private Network)：是利用共用网（ Internet）作为本机构个专用王志坚的通信载体，又称虚拟专用网</p>
<p>IP 地址分配问题：虚拟专用网中各主机所分配的地址应该是本机构可自由分配的专用地址，然后在路由器处进行加密，传输，在对方路由器解密</p>
<p><strong>NAT</strong> (Network Address Translation) 网络地址转换：使大量使用内部专用地址的用户共享少量外部全球地址来访问因特网上的主机和资源。</p>
<p><strong>NAPT</strong>：因为大部分网络应用在运输层协议 TCP 或 UDP 来传送数据，因此可以用了利用运输层端口号和 IP 地址一起转换，那就可以用一个全球 IP 地址使<strong>多个</strong>拥有本地地址的主机和因特网的主机进行通信</p>
<hr>
<h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><p>物理层、数据链路层和网络层共同解决了主机到主机的通信；而运输层的任务是<u>为不同主机上的应用进程提供直接的通信服务</u>，又称为端到端服务</p>
<h3 id="运输层端口号、复用与分用概念"><a href="#运输层端口号、复用与分用概念" class="headerlink" title="运输层端口号、复用与分用概念"></a>运输层端口号、复用与分用概念</h3><p><strong>运输端口号</strong></p>
<ul>
<li><p>是什么：运行在计算机上的进程使用进程标识符 PID 来标志，不同操作系统采用不同格式的进程标识符，为了能使运行在不同操作系统上的应用进程之间能够进行网络通信，使用同一方法对 TCP/IP 体系的运输层进行标记——<strong>端口号</strong></p>
</li>
<li><p>格式：16 比特表示，0~65535</p>
</li>
<li><p>分类：</p>
<ul>
<li>熟知端口号：0~1023，分配给 TCP/IP 结构体系中的一些重要应用协议（如， FTP—20/21；HTTP—80；DNS—53 ）</li>
<li>登记端口号：1024~49151，给没有熟知端口号的应用进程使用，需要登记，防止重复</li>
<li>短暂端口号：49152~65535，留给用户号应用进程选择暂时使用。当服务器收到用户的进程的报文时，就知道了用户使用的动态端口号，通信结束后，其他用户进程也能使用</li>
</ul>
</li>
</ul>
<p><strong>发送方的复用和接收方的分用</strong></p>
<p><img src="C:%5CUsers%5Chz%5CAppData%5CRoaming%5CTencent%5CUsers%5C1440961573%5CQQ%5CWinTemp%5CRichOle%5CIHGNX3%5D$%7BD5" alt="img">)AP4AYXPJYE7.png)</p>
<p>就像几个不同的应用进程通过不同的端口去使用UDP，UDP 和 TCP 通过不同的协议字段来使用 IP </p>
<p><strong>TCP/IP 体系常用协议和所使用的运输层熟知端口号</strong></p>
<p>[img]</p>
<h3 id="UDP-和-TCP-的对比"><a href="#UDP-和-TCP-的对比" class="headerlink" title="UDP 和 TCP 的对比"></a>UDP 和 TCP 的对比</h3><p>UDP</p>
<ul>
<li>无连接的UDP</li>
<li>支持单播、多播和广播</li>
<li>面向应用报文</li>
<li>尽最大努力交付，向上层提供无连接不可靠传输服务；不使用流量控制和拥塞控制（适用于 IP 电话、视频会议等实时应用）；</li>
<li>UDP 用户数据报首部仅 8 字节</li>
</ul>
<p>TCP</p>
<ul>
<li><p>面向连接的 TCP——“三报文握手”建立连接 &amp; “四报文挥手”释放连接</p>
</li>
<li><p>三报文握手建立连接，在基于 TCP 连接的可靠信道通信，因此仅支持单播</p>
</li>
<li><p>面向字节流</p>
</li>
<li><p>向上层提供面向连接可靠传输服务，不会出现误码、丢失、乱序、重复，使用流量控制和拥塞控制；适用要求可靠传输的应用，如文件传输</p>
</li>
<li><p>TCP 报文段首部最小 20 字节，最大 60 字节</p>
</li>
</ul>
<h3 id="TCP-的流量控制"><a href="#TCP-的流量控制" class="headerlink" title="TCP 的流量控制"></a>TCP 的流量控制</h3><p>是什么：流量控制（flow control），控制发送方的发送速率，让接收方来得及接受；利用<u>滑动窗口</u>机制课很方便地在 TCP 连接上实现对发送方的流量控制</p>
<p>怎么做：</p>
<ul>
<li>TCP 接收方利用自己的接受窗口大小来限制发送窗口的大小</li>
<li>TCP发送发送方收到零窗口通知后，应启动<strong>持续计时器</strong>，持续计时器超时后，向接收方发送零窗口探测报文</li>
</ul>
<h3 id="TCP-的拥塞控制"><a href="#TCP-的拥塞控制" class="headerlink" title="TCP 的拥塞控制"></a>TCP 的拥塞控制</h3><p>拥塞：(congestion) 若对网络中某一资源的需求超过了该资源（单款、交换节点中的缓存和处理机）所能提供的部分，网络性能就会变坏。若出现拥塞而不控制整个网络的吞吐量就会随输入负荷的增大而下降，最后达到<strong>死锁</strong>状态（吞吐量为0）</p>
<p><strong>拥塞算法及其基本原理</strong></p>
<p>发送方维护一个叫<strong>拥塞窗口cwnd</strong>的状态变量，其值取决于网络的拥塞程度，且动态变化</p>
<ul>
<li>维护原则：不出现阻塞， <code>cwnd</code>就大一些，阻塞就小一些</li>
<li>如何判断出现阻塞：发生超时重传</li>
</ul>
<p>发送方将拥塞窗口作为送窗口 <code>swnd</code> = <code>cwnd</code>，并维护一个<u>慢开始门限 <code>ssthresh</code></u>状态变量</p>
<ul>
<li><code>cwnd</code>&lt;<code>ssthresh</code>：开始慢开始算法</li>
<li><code>cwnd</code>&gt;<code>ssthresh</code>：停止慢开始算法，改而使用拥塞避免算法</li>
<li><code>cwnd</code>=<code>ssthresh</code></li>
</ul>
<p><strong>慢开始</strong>：拥塞窗口一直 double 至慢开始门限处</p>
<p><strong>拥塞避免</strong>：一个一个地增加；直至重传计时器超时，判断网络出现拥塞，于是：</p>
<pre><code>- 将`ssthresh`值更新为发生拥塞是的`cwnd`的一半
- 将 `cend`值减少为 1 ，重新执行慢开始算法</code></pre><p><strong>快重传</strong>：有时候只是丢失，而没用出现拥塞，所以没必要把拥塞创空设置为1降低传输效率。而快重传机制就是使发送方尽快进行重传，而不是等超时计时器超市再重传</p>
<ul>
<li>实现：<ul>
<li>接收方无需等到自己发送数据时捎带确认，而是立即发送确认</li>
<li>既是收到失序的报文段也要立即发出对已经收到的报文段的重复确认</li>
<li>一旦收到三个连续的重复确认，就将相应的报文段立即重传，不用等超时</li>
</ul>
</li>
</ul>
<p><strong>快恢复</strong>：收到三个重复确认，就知道无需启动慢开始算法，而执行块恢复算法</p>
<ul>
<li>发送方将<code>ssthresh</code>和<code>cwnd</code>调整为原来的 一半，开始实行拥塞避免算法</li>
<li>有的是将快恢复开始时的拥塞窗口再 +3</li>
</ul>
<h3 id="TCP-超时重传时间的选择"><a href="#TCP-超时重传时间的选择" class="headerlink" title="TCP 超时重传时间的选择"></a>TCP 超时重传时间的选择</h3><p>往返时间<code>RTT</code></p>
<p>超时重传时间<code>RTO</code></p>
<p>RTT 偏差的加权平均 RTT<sub>D</sub></p>
<ul>
<li>RFC 6298：每次测量得到的 RTT 不具有普遍适用性，因而使用每次测量得到的 RTT 样本，计算加权平均往返时间，再加上四倍的 RTT<sub>D</sub></li>
<li>Karn 算法及其修正：如果发生了重传，就难以准确确定 RTT 值了，Karn 算法中不采用重传样本的值。但是这样又可能是报文的时延增大了而且以后一直维持这个时延，那超时重传就无法更新。于是修正后：报文段重传一次，就把超时重传施加增大一些（如两倍）。</li>
</ul>
<h3 id="TCP-的运输连接管理"><a href="#TCP-的运输连接管理" class="headerlink" title="TCP 的运输连接管理"></a>TCP 的运输连接管理</h3><h4 id="TCP-连接的建立"><a href="#TCP-连接的建立" class="headerlink" title="TCP 连接的建立"></a>TCP 连接的建立</h4><p>TCP 连接需要解决的问题</p>
<ul>
<li>双方都确知对方的存在</li>
<li>双方能够协商一些参数（最大窗口值、是否使用窗口扩大选项、时间戳选项以及服务质量）</li>
<li>双方能对运输实例资源（缓存大小等）进行分配</li>
</ul>
<h5 id="三报文握手"><a href="#三报文握手" class="headerlink" title="三报文握手"></a>三报文握手</h5><img src="http://pictures-by-skylar.oss-cn-shenzhen.aliyuncs.com/img/Q~F8M91}9R_W9KF{S@}Q63P.png" alt="img" style="zoom:80%;" />

<p><u>来解释一下这些字符都是什么意思</u></p>
<p>同步标志位 <code>SYN</code>： 是 TCP 首部的一个字段，是在 TCP 连接建立时用来同步的序号。SYN 数据包指的是 SYN 值为 1 的 TCP 包，只有收到 SYN 包才能<strong>建立连接</strong>。</p>
<p><code>ACK</code> ：确认字符，在数据通信中，表示发来的数据已确认接收无误。</p>
<p>终止标志位 <code>FIN</code>：用来释放 TCP 连接</p>
<p><code>seq</code>：序列号，随机初始化而得，意思是，你方请求我已经收到，我方数据流就从这个数开始，只是做一个标记用吧</p>
<p><code>ack</code>：对收到的数据包的确认，值是期待收到的数据包的序列号</p>
<p>TCP 规定，SYN = 1 单位报文段不能携带数据，但消耗一个序号；而普通的确认报文段如果不携带数据，则不消耗序号。</p>
<p><u>第三次握手多余吗？</u></p>
<p>可以防止已失效的连接请求报文突然有传送到了 TCP 服务器，因而导致错误</p>
<h5 id="四报文挥手"><a href="#四报文挥手" class="headerlink" title="四报文挥手"></a>四报文挥手</h5><img src="http://pictures-by-skylar.oss-cn-shenzhen.aliyuncs.com/img/CBDBF118DBE19194ECE1F07499F15B20.png" alt="img" style="zoom:80%;" />

<p>最后的等待是因为：</p>
<p><u>保活计时器</u></p>
<p>方便 TCP 服务器发现客户端发生故障，关闭连接减少不必要的等待。</p>
<h3 id="TCP-首部格式"><a href="#TCP-首部格式" class="headerlink" title="TCP 首部格式"></a>TCP 首部格式</h3><p>复位标志位 RST：用来复位 TCP 连接。当 RST = 1 时，表明 TCP 连接出现了异常，必须释放连接再重新建立；RST 置1还用来拒绝一个非法报文段或打开一个 TCP 链接</p>
<hr>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>是干什么的：是计算机网络体系结构的最顶层，是设计和建立计算机网络的最终目的，也是计算机网络中发展最快的部分</p>
<h3 id="客户-服务器方式（C-S）和对等方式（P2P）"><a href="#客户-服务器方式（C-S）和对等方式（P2P）" class="headerlink" title="客户/服务器方式（C/S）和对等方式（P2P）"></a>客户/服务器方式（C/S）和对等方式（P2P）</h3><p>网络应用进程处于网络边缘的不同端系统上，通过彼此间的通信来完成某项任务。网络应用程序在各种端系统上的组织方式和他们之间的关系主要有</p>
<ul>
<li>Client/Server, C/S 方式</li>
</ul>
<p>服务集中型，服务器是服务提供方，总是处于运行状态，等待客户的服务请求。服务器具有固定端口号（HTTP 服务器的默认端口号为 80 ），运行服务器的主机也具有固定的 IP 地址。</p>
<ul>
<li>Peer-to-Peer 方式</li>
</ul>
<p>服务分散型，没有固定的服务请求者和提供者，对等方之间直接通信，P2P 文件共享、即时通信、分布式存储。具有可拓展性，成本更低，不需要庞大的服务器设施和服务器宽带。</p>
<h3 id="动态主机配置-DHCP"><a href="#动态主机配置-DHCP" class="headerlink" title="动态主机配置 DHCP"></a>动态主机配置 DHCP</h3><ul>
<li><p>是什么</p>
<p>动态主机配置 DHCP（Dynamic Host Configuration Protocol）提供了一种机制，允许一台计算机加入新网络时可以自动获取 IP 地址等网络配置信息而不用手工参与。</p>
</li>
<li><p>怎么实现</p>
<p>DHCP DISCOVER : DHCP 发现报文</p>
<p>DHCP OFFER : DHCP 提供报文</p>
<p>DHCP REQUEST : DHCP请求报文</p>
<p>DHCP ACK : DHCP 确认报文</p>
<p>DHCP NACK : DHCP 否认报文</p>
<p>DHCP RELEASE : DHCP 释放报文</p>
</li>
<li><p>基本流程：</p>
<ul>
<li>客户在为获取到 IP 地址时使用地址 0.0.0.0</li>
<li>DHCP 报文在运输层使用 UDP 协议封装，客户使用的 UDP 端口号为68，服务器为 67</li>
</ul>
<p>客户 DISCOVER –&gt; 服务器们 OFFER –&gt;  客户选择，回复 REQUEST –&gt; 相应服务器确认 ACK –&gt; 【开始】</p>
<p>0.5 倍租用期时 重新REQUEST …..</p>
<p>随时解除 IP 地址租约 DHCP RELEASE</p>
</li>
<li><p>DHCP 中继代理</p>
<p>在每一个网络上都设置一个 DHCP 服务器会是 DHCP 服务器太多，因此现在是使每一个网络至少有一个 DHCP 中继代理器（通常是一台路由器），给它配置 DHCP 服务器的 IP 地址，作为各网络中计算机和 DHCP 服务器中间的桥梁</p>
</li>
</ul>
<h3 id="域名系统-DNS"><a href="#域名系统-DNS" class="headerlink" title="域名系统 DNS"></a>域名系统 DNS</h3><ul>
<li>是什么</li>
</ul>
<p>是因特网使用的命名系统，用来把便于人们积极的具有特定含义的主机名（域名），转换为便于机器处理的 IP 地址。</p>
<ul>
<li>分层</li>
</ul>
<p>层次结构的命名树作为主机的名字（域名），并使用分布式的域名系统 DNS ，DNS 使大多数的域名都在本地解析，只有少量需要在因特网上通信，因此效率很高</p>
<p>域名和 IP 地址的映射关系必须保存在域名服务器中，DNS 使用分布在各地的域名服务器来实现域名到 IP 地址的转换</p>
<ul>
<li>域名层级</li>
</ul>
<p>顶级域名 TLD</p>
<p>二级域名</p>
<ul>
<li>域名服务器可分为</li>
</ul>
<p>根域名服务器</p>
<p>顶级域名服务器</p>
<p>权限域名服务器</p>
<p>本地域名服务器</p>
<ul>
<li><p>查询过程</p>
<ul>
<li>递归查询</li>
<li>迭代查询</li>
</ul>
</li>
<li><p>DNS 高速缓存</p>
<p>如果已经有用户查询过某地址，他就会在本地域名服务器上的高速缓存中存在，再次访问时就可以直接查询，无需一层层迭代查询。会到期删除。</p>
<p>许多用户主机在启动时会从本地域名服务器下载域名和 IP 地址的全部的全部数据，维护存放在自己最近使用的域名高速缓存中。</p>
</li>
</ul>
<h3 id="文件传送协议-FTP（File-Transfer-Protocol）"><a href="#文件传送协议-FTP（File-Transfer-Protocol）" class="headerlink" title="文件传送协议 FTP（File Transfer Protocol）"></a>文件传送协议 FTP（File Transfer Protocol）</h3><p>FTP 提供交互的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限</p>
<p>和 屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算之间传送文件</p>
<ul>
<li>FTP 服务器 FTP 客户端之间建立<u>两个并行的 TCP 连接</u>：</li>
</ul>
<p><u>数据连接</u>：用于文件传输，在每次文件传输时才建立，传输结束关闭</p>
<p>默认情况下， FTP 进行使用 TCP 21 端口进行控制连接，FTP 20 端口进行数据连接。但是是否使用TCP 20 端口建立数据连接与传输模式相关，主动方式使用 TCP 20 端口，被动方式由服务器和客户端自行协商决定。</p>
<h3 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h3><p>邮局协议 POP</p>
<p>因特网邮件访问协议 IMAP</p>
<h3 id="万维网"><a href="#万维网" class="headerlink" title="万维网"></a>万维网</h3><ul>
<li>是什么</li>
</ul>
<p>万维网并非特殊的计算机网络，是一个大规模、联机式地信息储藏所，是运行在因特网上的一个<u>分布式应用</u>，利用页支架的超链接将不同的网站的网页链接成一张逻辑上的信息网。</p>
<h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>为了方便地访问在世界范围的文档，万维网使用统一资源定位符 URL 来指明因特网上任何种类“资源”的位置。URL 的一般形式由以下四个部分组成：</p>
<p>&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</p>
<ul>
<li>www 的文档：HTML、CSS、 JS</li>
</ul>
<h4 id="超文本传输协议-HTTP"><a href="#超文本传输协议-HTTP" class="headerlink" title="*超文本传输协议 HTTP *"></a>*<em>超文本传输协议 HTTP *</em></h4><ul>
<li><p>是什么</p>
<p>HTTP 定义了浏览器（即万维网客户进程）怎样向万维网服务器请求万维网文档，以及万维网如何把万维网文档传给浏览器</p>
</li>
<li><p>HTTP/1.0</p>
<p>采用非连续连接方式，每次浏览器要请求一个文件都要与服务器建立 TCP 连接，当收到响应后就立即关闭连接。为了减少时延，浏览器通常建立多个并行的 TCP 连接同时请求多个对象，但这样会大量占用万维网服务器资源。</p>
</li>
<li><p>HTTP/1.1</p>
<p>非持续连接，在该方式下，万维网在发送响应后仍然保持这条连接，还可以继续交换报文。并布局向在传送同一个页面上引用的对象，而是这些文档都在一个服务器上就行。</p>
<p>可以使用流水线方式工作。</p>
</li>
<li><p>HTTP 报文格式</p>
<p>  请求报文</p>
<p>  <img src="C:%5CUsers%5Chz%5CAppData%5CRoaming%5CTencent%5CUsers%5C1440961573%5CQQ%5CWinTemp%5CRichOle%5C@$DX2%5BGNJIWOER2%5D$ML%25L" alt="img">)M.png)</p>
<p>  响应报文</p>
</li>
</ul>
<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><ul>
<li><p>是什么</p>
<p>早期的万维网应用非常简单，仅仅是用户查看存放在不同服务器上的各种静态文档，因此 HTTP 被设计成一种无状态的协议。但是万维网应用复杂了，往往需要万维网服务器能识别用户。而<code>Cookie</code>就是一种对无状态的 HTTP 进行状态化的技术。</p>
</li>
<li><p>工作流程</p>
<ul>
<li>HTTP 请求，建立 TCP 连接，端口号 80</li>
<li>生成 Cookie 识别码，并以此为索引在服务器后端数据库创建一个项目，用来记录该用户该问该网站的各种信息</li>
<li>HTTP 响应，Set-Cookie 字段</li>
<li>用户主机将 Cookie 信息存入文件</li>
<li>再次请求前就可以先从文件中读取 Cookie ，在 HTTP 请求中带上，万维网服务器可以根据 Cookie 索引识别出用户，并返回该用户的个性化网页</li>
</ul>
</li>
</ul>
<h4 id="万维网缓存和代理服务器"><a href="#万维网缓存和代理服务器" class="headerlink" title="万维网缓存和代理服务器"></a>万维网缓存和代理服务器</h4><ul>
<li><p>是什么</p>
<p>万维网中可以通过使用缓存机制提高万维网的效率。万维网缓存又称 Web 缓存，口位于客户机，也可位于中间系统上（代理服务器）</p>
<p>Web 缓存把最近的一些请求和相应暂存在本地磁盘中，当新请求到达时，若发现这个请求与暂时存放的请求相同就不用再按 URL 地址再去因特网访问了。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>happy birthday</title>
    <url>/2020/07/15/happy-birthday/</url>
    <content><![CDATA[<p>雨天生日快乐</p>
<a id="more"></a>

<iframe src="//player.bilibili.com/player.html?aid=883812762&bvid=BV1yK4y1s7UL&cid=21248569&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe>

<p>我猜你想知道怎么插入视频，其实灰常简单，只需要把视频源链接放到用到 <code>\&lt;iframe&gt;</code>标签（这个标签是可以理解为用来引入其他页面），添加 <code>src</code>属性，属性值为路径就 OK 啦</p>
<p>像 b 站这种视频就更简单了</p>
<img src="http://pictures-by-skylar.oss-cn-shenzhen.aliyuncs.com/img/903E7FF3576E3DEC5098D2487271744E.jpg" alt="img" style="zoom:67%;" />

<p>把这个链接复制粘贴一下就能以默认样式引入视频啦~</p>
<hr>
<p><img src="http://pictures-by-skylar.oss-cn-shenzhen.aliyuncs.com/img/qqpyimg1594744286.gif" alt="img"></p>
<div align="center">和彬彬幸福美满！！大厂预定！！一起发财！！！！！<div>]]></content>
  </entry>
  <entry>
    <title>hexo</title>
    <url>/2020/07/05/hexo/</url>
    <content><![CDATA[<p>hexo</p>
<a id="more"></a>

<h2 id="next主题优化"><a href="#next主题优化" class="headerlink" title="next主题优化"></a>next主题优化</h2><h3 id="选择主题"><a href="#选择主题" class="headerlink" title="选择主题"></a>选择主题</h3><h3 id="分类和标签"><a href="#分类和标签" class="headerlink" title="分类和标签"></a>分类和标签</h3><ul>
<li>设置</li>
<li>实现分类层级</li>
</ul>
<h3 id="代码块样式"><a href="#代码块样式" class="headerlink" title="代码块样式"></a>代码块样式</h3><ul>
<li>样式</li>
<li>复制</li>
</ul>
<h3 id="头像显示"><a href="#头像显示" class="headerlink" title="头像显示"></a>头像显示</h3><p>sidebar avatar打开<br>首先你要把博客的社交模块打开<br>在主题配置文件 _config.yml 的 social<br>在主题的 source/images/ 下的 avatar.gif 更换成你的图片<br>好像没出来</p>
<h3 id="加入分享功能"><a href="#加入分享功能" class="headerlink" title="加入分享功能"></a>加入分享功能</h3><p>项目的 _config.yml 中加入<br>duoshuo_share 字段，值为 true<br>好像也没出来</p>
<h3 id="链接样式改变"><a href="#链接样式改变" class="headerlink" title="链接样式改变"></a>链接样式改变</h3><h3 id="图片显示"><a href="#图片显示" class="headerlink" title="图片显示"></a>图片显示</h3>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
  </entry>
  <entry>
    <title>npm卸载及重装</title>
    <url>/2020/07/03/npm%E5%8D%B8%E8%BD%BD%E5%92%8C%E9%87%8D%E8%A3%85/</url>
    <content><![CDATA[<p>删得删彻底</p>
<a id="more"></a>

<p>感觉是前几天学 npm 的时候太过于放飞自我，把 npm 给玩坏了…..</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>几乎 install 所有的包都会失败，然后提示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm WARN registry Unexpected warning <span class="keyword">for</span> https://registry.npmjs.org/: Miscellaneous Warning ERR_OSSL_PEM_NO_START_LINE: error:0909006C:PEM routines:get_name:no start line</span><br><span class="line">npm WARN registry Using stale data from https://registry.npmjs.org/ due to a request error during revalidation.</span><br><span class="line">npm ERR! code ETARGET</span><br><span class="line">npm ERR! notarget No matching version found <span class="keyword">for</span> npm@16.14.4.</span><br><span class="line">npm ERR! notarget In most cases you or one of your dependencies are requesting</span><br><span class="line">npm ERR! notarget a package version that doesn<span class="string">'t exist.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">npm ERR! A complete log of this run can be found in:</span></span><br><span class="line"><span class="string">npm ERR!     C:\Users\hz\AppData\Roaming\npm-cache\_logs\2020-07-03T12_42_22_735Z-debug.log</span></span><br></pre></td></tr></table></figure>

<p>上网搜了各种方法都没能解决，然后决定卸掉重来，然鹅卸载好像也有坑</p>
<h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p>我用的是粗暴的删除文件夹方法：</p>
<ol>
<li><p>找到<code>C:\Users\admin\AppData\Roaming</code> 下手动删除 <code>npm</code> 和 <code>npm-cache</code> 文件夹</p>
</li>
<li><p>卸载 <code>Node.js</code> 再重新安装，那新的 npm 就被重新安装啦</p>
</li>
</ol>
<p>然鹅…</p>
<p>卸载之后不仅 npm install 依然用不了，随着 npm 文件夹一起被删掉的 hexo 也用不了而且<br>还下不回来…</p>
<p>后来看到<a href="https://blog.csdn.net/u013591091/article/details/80491809?utm_source=app" target="_blank" rel="noopener">这篇文章</a>才发现是我的 ‘.mpmrc’文件没有删除</p>
<p>‘.mpmrc’文件不在前面删掉的两个文件夹里，而是在<strong>用户文件夹</strong>里</p>
<h2 id="重装"><a href="#重装" class="headerlink" title="重装"></a>重装</h2><p>这个时候重装就可以愉快地用啦</p>
<p>安装的时候别忘了勾选添加到 PATH 中</p>
<p>以及 通过 npm 安装的一些 -g 的包要重新装一下</p>
<p>以及 cnpm 真好用</p>
<h2 id="hexo你怎么了"><a href="#hexo你怎么了" class="headerlink" title="hexo你怎么了"></a>hexo你怎么了</h2><p>重装了 hexo 之后好像一切都正常，我准备把今天的坑发一下，然鹅….发现更新之后博客页面变成了空白页<br>一般这种情况都是主题没绑定好，可能是因为手动删除了 npm 的文件夹之后把 hexo 的一些插件也给删掉了</p>
]]></content>
      <categories>
        <category>一些坑</category>
      </categories>
      <tags>
        <tag>一些坑</tag>
      </tags>
  </entry>
  <entry>
    <title>npm的基本用法</title>
    <url>/2020/06/27/npm%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>npm is the world’s largest software registry. Open source developers from every continent use npm to share and borrow packages, and many organizations use npm to manage private development as well.</p>
<a id="more"></a>

<p><strong>目录</strong>：</p>
<!-- TOC -->

<ul>
<li><a href="#hello-npm">hello NPM</a></li>
<li><a href="#安装">安装</a></li>
<li><a href="#packagejson">package.json</a></li>
<li><a href="#understanding-packages-and-modules">Understanding Packages and Modules</a></li>
<li><a href="#常用命令">常用命令</a></li>
<li><a href="#config">config</a></li>
<li><a href="#别的一些">别的一些</a></li>
<li><a href="#npm-script">npm-Script</a></li>
</ul>
<!-- /TOC -->

<h2 id="hello-NPM"><a href="#hello-NPM" class="headerlink" title="hello NPM"></a>hello NPM</h2><p>npm is the world’s largest software registry. Open source developers from every continent use npm to share and borrow packages, and many organizations use npm to manage private development as well.</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li><p>安装npmn</p>
 </br>

 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#  1. 升级、查看版本号</span></span><br><span class="line">npm install npm -g</span><br><span class="line">npm -v</span><br><span class="line">npm install npm@latest -g</span><br><span class="line">npm install npm@next -g</span><br><span class="line"><span class="comment">#  2. 淘宝镜像安装</span></span><br><span class="line">npm install -g cnpm --registry=https:<span class="comment">#registry.npm.taobao.org</span></span><br><span class="line"><span class="comment"># 然后就可以使用 cnpm 命令进行安装了</span></span><br></pre></td></tr></table></figure>

 </br>
</li>
<li><p>安装/卸载/更新模块</p>
 </br>

 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 本地安装</span></span><br><span class="line">npm install &lt;Module Name&gt;</span><br><span class="line"><span class="comment">#  --- 安装之后这个包就会被放在工程目录的 node_module 目录中了</span></span><br><span class="line"><span class="comment">#  --- 可以通过require()引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 全局安装(global)</span></span><br><span class="line">npm install &lt;Module Name&gt; -g</span><br><span class="line"><span class="comment">#  --- 安装之后放在 /usr/local 下或者 node 安装目录中</span></span><br><span class="line"><span class="comment">#  --- 可以直接在命令行里面使用了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 卸载</span></span><br><span class="line">npm uninstall &lt;Module Name&gt;</span><br><span class="line"><span class="comment"># 如需从 package.json 中删除依赖</span></span><br><span class="line">npm uninstall --save &lt;Module Name&gt;</span><br><span class="line">npm uninstall --save-dev &lt;Module Name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 检查某模块在不在</span></span><br><span class="line">dir node_module</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 更新本地的包</span></span><br><span class="line">npm update</span><br><span class="line">npm outdate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. npm search</span></span><br></pre></td></tr></table></figure>

 </br>
</li>
<li><p>查看安装信息</p>
 </br>

<ul>
<li><p>安装过程的输出内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">express@4.13.3 node_modules/express</span><br><span class="line"><span class="comment">#  安装的包名称  安装的位置</span></span><br><span class="line">├── escape-html@1.0.2</span><br><span class="line">......</span><br><span class="line">└── ....</span><br></pre></td></tr></table></figure>

</br>
</li>
<li><p>查看安装信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm list -g</span><br><span class="line"><span class="comment"># 查看所有全局安装的模块</span></span><br><span class="line">npm list \&lt;Module Name&gt;</span><br><span class="line"><span class="comment"># 查看某个模块的安装信息</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><p>安装之后位于模块的目录下，定义包的属性<br>列出安装和依赖信息、允许自定义命令、方便包的共享</p>
<ol>
<li><p>package.json 的参数</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!-- - name  包名</span><br><span class="line">- version   版本号</span><br><span class="line">- homepage / bugs  包的directory</span><br><span class="line">- dependencies  依赖包列表</span><br><span class="line">    --- 如果没有相应的包，会随模块安装到 node_module 目录</span><br><span class="line">- repositoty    包代码存放地址（git / svn / github）</span><br><span class="line">- main  指定程序主入口文件，require(<span class="string">'moduleName'</span>) 就会加载这个文件</span><br><span class="line">    像 webpack 有也有指定操作的主入口文件，默认是模块根目录下的 index.js</span><br><span class="line">- keyords   关键字</span><br><span class="line">- script    设置默认脚本 --&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建 package.json 文件</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm init</span><br><span class="line">npm niit -y   <span class="comment"># 按默认值创建</span></span><br><span class="line">npm <span class="built_in">set</span> init.author.email <span class="string">"wombat@npmjs.com"</span></span><br><span class="line"><span class="comment">#  也可以指定一些值啦</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Customize</span></span><br><span class="line"><span class="comment"># 给创建的 package.json 设置默认参数</span></span><br><span class="line"><span class="comment"># --- 创建一个 .npm-init.js</span></span><br><span class="line">module.exports = &#123;</span><br><span class="line">customField: <span class="string">'Custom Field'</span>,</span><br><span class="line">otherCustomField: <span class="string">'This field is really cool'</span></span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定依赖项Specifying Dependencies</p>
</li>
</ol>
<p>也是自定义包的一个部分</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># —— "dependencies"</span></span><br><span class="line"><span class="comment">#  |—— required by your application in production</span></span><br><span class="line"><span class="comment"># —— "devDependencies"</span></span><br><span class="line"><span class="comment">#  |—— are only needed for development and testing</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># | 步骤</span></span><br><span class="line"><span class="comment"># |—— 在 package.json 中设置引入</span></span><br><span class="line"><span class="comment"># |  |—— 包对象中创建一个指向对象的称为 dependencies</span></span><br><span class="line"><span class="comment"># |—— install flags</span></span><br><span class="line"><span class="comment"># |  |——  To add an entry to your package.json's dependencies</span></span><br><span class="line">        npm install &lt;package_name&gt; --save</span><br><span class="line"><span class="comment"># |  |——  dev-dependencies</span></span><br><span class="line">        npm install &lt;package_name&gt; --save</span><br></pre></td></tr></table></figure>

<h2 id="Understanding-Packages-and-Modules"><a href="#Understanding-Packages-and-Modules" class="headerlink" title="Understanding Packages and Modules"></a>Understanding Packages and Modules</h2><p>这两个居然不是同一个东西</p>
<ol>
<li><p>package —— 包是由package.json描述的文件或目录</p>
</li>
<li><p>module —— 模块是节点可以加载的任何文件或目录<br> 在这里只是 package 里的一部分啦，像js里面也也会输出module<br> A folder with a package.json file containing a main field.</p>
</li>
</ol>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- install &amp; uninstall</span><br><span class="line">- publish &amp; unpublish</span><br><span class="line">- <span class="built_in">help</span></span><br><span class="line">- -g</span><br><span class="line">- npm update ..</span><br><span class="line">- npm cache clear</span><br><span class="line"></span><br><span class="line">- npm bin   显式npm的bin文件夹的路径</span><br><span class="line">- npm build    创建一个package文件夹</span><br><span class="line">    是由 npm link 和 npm install 命令组成的</span><br><span class="line">- npm cache    操作缓存文件</span><br><span class="line">    1. add  可以将指定的包添加到本地缓存</span><br><span class="line">    2. clean    删除所有数据的缓存文件</span><br><span class="line">    3. verify   验证缓存文件的正确性，不必要的进行垃圾收集</span><br><span class="line"></span><br><span class="line">配置相关</span><br><span class="line"><span class="comment"># - npm gets its config settings from the</span></span><br><span class="line"><span class="comment">#     1. command line,</span></span><br><span class="line"><span class="comment">#     2. environment variables,</span></span><br><span class="line"><span class="comment">#     3. npmrc files</span></span><br><span class="line"><span class="comment">#     4. the package.json file.</span></span><br><span class="line"></span><br><span class="line">- config    操作npm的配置文件，sub-commands：</span><br><span class="line">    |—— npm config <span class="built_in">set</span> key value</span><br><span class="line">    |—— get key</span><br><span class="line">    |—— list</span><br><span class="line">    |—— delete key</span><br><span class="line">    |—— edit</span><br><span class="line">- npmrc</span><br></pre></td></tr></table></figure>

<h2 id="config"><a href="#config" class="headerlink" title="config"></a>config</h2><p>npm gets its configuration from:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. <span class="built_in">command</span> line flags</span><br><span class="line"></span><br><span class="line">    --foo bar   <span class="comment">#  sets the foo 配置参数 to bar</span></span><br><span class="line">    A -- argument  <span class="comment">#  解析器停止读取flags  ?</span></span><br><span class="line">    --flag   <span class="comment">#  set the value true</span></span><br><span class="line">    --flag1 --flag2   <span class="comment">#  set both true</span></span><br><span class="line"></span><br><span class="line">2. environment variables</span><br><span class="line">3. npmrc Files</span><br><span class="line">4. default configs</span><br><span class="line">5. shorthands and other cli niceties</span><br><span class="line"> /* ___________________________________</span><br><span class="line">    |  shorthands  |  flags           |</span><br><span class="line">    +—————————————————————————————————+</span><br><span class="line">    |      -v      |  -version        |</span><br><span class="line">    |-h, --<span class="built_in">help</span>, -H|  --usage         |</span><br><span class="line">    |-s, --slicent | --loglevel silent|</span><br><span class="line">    |      -g      |  --global        |</span><br><span class="line">    |      -m      |  --message       |</span><br><span class="line">    |      -s      |  --save          |</span><br><span class="line">    |      -P      |  --save-prod     |</span><br><span class="line">    |      -D      |  --save-dev      |</span><br><span class="line">    |      -O      |  --save-optional |</span><br><span class="line">    |      -y      |  -yes            |</span><br><span class="line">    |      -n      |  -yes <span class="literal">false</span>      |</span><br><span class="line">    ———————————————————————————————————</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">组合：几个字母组</span><br><span class="line">1. --<span class="built_in">help</span>   直接解析</span><br><span class="line">2. --par   拓展解析成parseable</span><br><span class="line">3. -gpld    解析为npm ls --global --parseable --long --loglevel info</span><br></pre></td></tr></table></figure>

<h2 id="别的一些"><a href="#别的一些" class="headerlink" title="别的一些"></a>别的一些</h2><p>npmrc —— the npm config files<br>npm-folders —— npm puts various things on your computer. This document will tell you what it puts where.</p>
<h2 id="npm-Script"><a href="#npm-Script" class="headerlink" title="npm-Script"></a>npm-Script</h2><p>–</p>
<p>from<br><a href=""https:#www.runoob.com/nodejs/nodejs-npm.html"">菜鸟教程–NPM 使用介绍</a><br><a href=""https:#www.npmjs.cn/"">NPM 官方文档</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title>先Mark住Markdown的常用符</title>
    <url>/2020/04/29/MarkMarkdown/</url>
    <content><![CDATA[<p>终于终于到了可以写博文的环节了，第一篇那就先总结一下我觉得我以后要markdown的一些常用语法吧，一边学一边写一边总结厚！</p>
<a id="more"></a>

<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p> <a href="#一一些基础语法">一、一些基础语法</a></p>
<ul>
<li><a href="#代码块">代码块</a></li>
<li><a href="#行内代码块">行内代码块</a></li>
<li><a href="#整段代码块">整段代码块</a></li>
<li><a href="#常用需要转义的符号">常用需要转义的符号</a></li>
<li><a href="#加粗或斜体">加粗或斜体</a></li>
<li><a href="#设置标题">设置标题</a></li>
<li><a href="#超链接行内式和参考式自动链接">超链接：行内式和参考式，自动链接</a></li>
<li><a href="#删除线">删除线</a></li>
</ul>
<p><a href="#二引用插入点什么">二、引用/插入点什么</a></p>
<ul>
<li><p><a href="#文字引用">文字引用</a></p>
</li>
<li><p><a href="#列表">列表</a></p>
</li>
<li><p><a href="#目录结构">目录结构</a></p>
</li>
<li><p><a href="#插入图像">插入图像</a></p>
</li>
<li><p><a href="#写公式">写公式</a></p>
</li>
<li><p><a href="#流程图">流程图</a></p>
</li>
<li><p><a href="#表格">表格</a></p>
</li>
<li><p><a href="#加入html标签">加入html标签</a></p>
</li>
<li><p><a href="#代办事项">代办事项</a></p>
<p><a href="#三最后说点什么">三、最后说点什么</a></p>
</li>
</ul>
<h2 id="一、一些基础语法"><a href="#一、一些基础语法" class="headerlink" title="一、一些基础语法"></a>一、一些基础语法</h2><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>好像写语法总结需要把代码放上来，那就先写怎么引用代码叭（禁止套娃–||）</p>
<h4 id="行内代码块"><a href="#行内代码块" class="headerlink" title="行内代码块"></a>行内代码块</h4><p>用单引号括住就ok了<br>这是设置字体的html代码’<font color="red">红色</font>‘</p>
<h4 id="整段代码块"><a href="#整段代码块" class="headerlink" title="整段代码块"></a>整段代码块</h4><p>使用四个缩进或者双引号单引号表示代码块<br>反引号加语言名字</p>
<h3 id="常用需要转义的符号"><a href="#常用需要转义的符号" class="headerlink" title="常用需要转义的符号"></a>常用需要转义的符号</h3><p>没想到一开头就要用到转义了hhh<br>Markdown里转义也是在特殊字符前面加一个反斜杠<br>常见的需呀转义的符号有<br>\ ‘ * _ {} [] () # + - . !</p>
<h3 id="加粗或斜体"><a href="#加粗或斜体" class="headerlink" title="加粗或斜体"></a>加粗或斜体</h3><p>用*包着对应的文字，左右</p>
<h3 id="设置标题"><a href="#设置标题" class="headerlink" title="设置标题"></a>设置标题</h3><p>在标题前面加’#’，越低级的标题用越多的’#’，可以加1~6个</p>
<h3 id="超链接：行内式和参考式，自动链接"><a href="#超链接：行内式和参考式，自动链接" class="headerlink" title="超链接：行内式和参考式，自动链接"></a>超链接：行内式和参考式，自动链接</h3><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>用~~包住语句就好啦</p>
<h2 id="二、引用-插入点什么"><a href="#二、引用-插入点什么" class="headerlink" title="二、引用/插入点什么"></a>二、引用/插入点什么</h2><h3 id="文字引用"><a href="#文字引用" class="headerlink" title="文字引用"></a>文字引用</h3><p>用<code>&gt;</code>表示文字引用</p>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>无序列表：用<code>*</code>、<code>+</code>、<code>-</code>都可以表示无序列表<br>有序列表：用数字和点表示有序列表</p>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>在文中任意位置输入单击，点插入OTC就好啦即可显示全文内容啦<br><code>&lt;!-- TOC --&gt;</code></p>
<h3 id="插入图像"><a href="#插入图像" class="headerlink" title="插入图像"></a>插入图像</h3><p>使用 <code>![描述](url)</code> 插入图像</p>
<p>###　写公式</p>
<p><code>$</code>写行内公式，<code>$$</code>写整行公式</p>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><ol>
<li>流程图从flow开始</li>
<li>然后需要定义tag，基本类型包括：</li>
</ol>
<p>-start（开始框）<br>-end<br>-operation（执行）<br>-subroutine （分支）<br>-condition（条件结构）<br>-condition（yes和no，这个好像不需要定义啦）<br>3. 用=&gt;来定义，用-&gt;来表示路径</p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>列：直接用|代替表格的竖线；行：直接换行就行<br>第二行用来表示字体显示的位置’-‘表示靠左，’-‘表示靠右，’:–:’表示居中</p>
<h3 id="加入html标签"><a href="#加入html标签" class="headerlink" title="加入html标签"></a>加入html标签</h3><p>加个标签改变某个东东的属性这样子<br><font color="red">我是一段红色加粗的字</font></p>
<h3 id="代办事项"><a href="#代办事项" class="headerlink" title="代办事项"></a>代办事项</h3><p>list前加<code>[]</code>或<code>[×]</code>表示完成或未完成</p>
<p>[]1. xuexi</p>
<h3 id="插入-emoji"><a href="#插入-emoji" class="headerlink" title="插入 emoji"></a>插入 <code>emoji</code></h3><p>看这里 <a href="https://github.com/ikatyang/emoji-cheat-sheet/blob/master/README.md" target="_blank" rel="noopener">emoji-cheat-sheet</a></p>
<table>
<thead>
<tr>
<th align="center">emoji</th>
<th align="left">shortcode</th>
</tr>
</thead>
<tbody><tr>
<td align="center">:rofl:</td>
<td align="left"><code>:rofl:</code></td>
</tr>
<tr>
<td align="center">:sweat_smile:</td>
<td align="left"><code>:sweat_smile:</code></td>
</tr>
<tr>
<td align="center">:upside_down_face:</td>
<td align="left"><code>:upside_down_face:</code></td>
</tr>
<tr>
<td align="center">:smiling_face_with_three_hearts:</td>
<td align="left"><code>:smiling_face_with_three_hearts:</code></td>
</tr>
<tr>
<td align="center">:star_struck:</td>
<td align="left"><code>:star_struck:</code></td>
</tr>
<tr>
<td align="center">:stuck_out_tongue_closed_eyes:</td>
<td align="left"><code>:stuck_out_tongue_closed_eyes:</code></td>
</tr>
<tr>
<td align="center">:sunglasses:</td>
<td align="left"><code>:sunglasses:</code></td>
</tr>
</tbody></table>
<h2 id="三、最后说点什么"><a href="#三、最后说点什么" class="headerlink" title="三、最后说点什么"></a>三、最后说点什么</h2><p>8行，我真的困了，不知到上面写的能实现多少，先挖个坑，改天来填</p>
<img src="齐神说晚安.jpg" width="100px">

<p><img src="%E9%BD%90%E7%A5%9E%E8%AF%B4%E6%99%9A%E5%AE%89.jpg" alt="alt"></p>
<p>为啥图片显示不了哦？！</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>Markdown</category>
      </categories>
  </entry>
</search>
